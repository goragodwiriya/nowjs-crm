{"version":3,"file":"now.serviceworker.min.js","sources":["../js/ServiceWorkerManager.js"],"sourcesContent":["/**\n * ServiceWorkerManager\n *\n * Manages the registration, updates, and lifecycle of a service worker\n * for the Now.js framework, with automatic caching of JavaScript files\n * and push notification support.\n *\n * @example\n * // Initialize with default options\n * ServiceWorkerManager.init();\n *\n * @example\n * // Initialize with custom options\n * ServiceWorkerManager.init({\n *   scope: '/',\n *   version: '1.0.0',\n *   cacheName: 'now-js-cache-v1',\n *   debug: true,\n *   precache: ['/index.html', '/css/styles.css'],\n *   strategies: {'/api/': 'network-first', '/images/': 'cache-first'},\n *   push: {enabled: true, publicKey: 'YOUR_VAPID_PUBLIC_KEY'}\n * });\n */\nconst ServiceWorkerManager = {\n  config: {\n    enabled: false,\n    serviceWorkerPath: '/service-worker.js',\n    scope: '/',\n    version: '1.0.0',\n    cacheName: 'now-js-cache',\n    debug: false,\n    updateInterval: 24 * 60 * 60 * 1000, // 24 hours\n    precache: [\n      '/',\n      '/index.html'\n    ],\n    cacheJavascriptFiles: true,\n    cachePatterns: [\n      /\\.js$/,      // JavaScript files\n      /\\.css$/,     // CSS files\n      /\\.html$/,    // HTML files\n      /\\.json$/,    // JSON files\n      /\\.png$/,     // PNG images\n      /\\.jpe?g$/,   // JPEG images\n      /\\.svg$/,     // SVG images\n      /\\.woff2?$/,  // Web fonts\n      /\\.ttf$/      // TrueType fonts\n    ],\n    networkFirst: [],\n    excludeFromCache: [],\n    notifyOnUpdate: true,\n    offlineContent: null,\n    push: {\n      enabled: false,\n      publicKey: null, // VAPID public key\n      userVisibleOnly: true\n    },\n    strategies: {} // Optional caching strategies\n  },\n\n  state: {\n    initialized: false,\n    registration: null,\n    updateFound: false,\n    installingWorker: null,\n    offlineReady: false,\n    lastUpdateCheck: 0,\n    status: 'unregistered',\n    errors: [],\n    pushEnabled: false,\n    pushSubscription: null\n  },\n\n  /**\n   * Initialize the ServiceWorkerManager with provided options\n   * @param {Object} options - Configuration options\n   * @returns {ServiceWorkerManager} - This instance for chaining\n   */\n  async init(options = {}) {\n    try {\n      if (this.state.initialized) return this;\n\n      this.config = {...this.config, ...options};\n\n      if (!this.config.enabled) {\n        this.log('Service Worker is disabled in configuration');\n        return this;\n      }\n\n      if (!this.isSupported()) {\n        this.log('Service Worker is not supported in this browser');\n        return this;\n      }\n\n      await this.registerServiceWorker();\n      this.setupUpdateChecks();\n      await this.setupPushNotifications();\n      await this.updateConfig();\n\n      this.state.initialized = true;\n      return this;\n    } catch (error) {\n      this.handleError(error);\n      return this;\n    }\n  },\n\n  /**\n   * Updates the service worker configuration by sending a message to the active service worker.\n   * The configuration includes cache name, precache URLs, cache patterns, network-first patterns,\n   * exclude patterns, caching strategies (e.g., 'network-first', 'cache-first', 'stale-while-revalidate'),\n   * and push notification settings.\n   * @async\n   * @returns {Promise<void>} - Returns void if successful, or if no registration exists\n   * @throws {Error} - Handled internally by handleError method\n   */\n  async updateConfig() {\n    if (!this.state.registration) return;\n    try {\n      let sw = this.state.registration.active;\n      if (!sw) {\n        // Wait for the service worker to become active\n        await new Promise(resolve => {\n          const checkActive = () => {\n            if (this.state.registration.active) {\n              resolve();\n            } else {\n              setTimeout(checkActive, 100); // Poll every 100ms\n            }\n          };\n          checkActive();\n          this.state.registration.addEventListener('updatefound', () => {\n            const worker = this.state.registration.installing;\n            if (worker) {\n              worker.addEventListener('statechange', () => {\n                if (worker.state === 'activated') resolve();\n              });\n            }\n          });\n        });\n        sw = this.state.registration.active;\n      }\n      if (!sw) throw new Error('No active service worker after waiting');\n\n      const toPatternSource = arr => arr.map(p => p instanceof RegExp ? p.source : p);\n      sw.postMessage({\n        type: 'UPDATE_CONFIG',\n        payload: {\n          cacheName: this.config.cacheName,\n          precacheUrls: this.config.precache,\n          cachePatterns: toPatternSource(this.config.cachePatterns),\n          networkFirstPatterns: toPatternSource(this.config.networkFirst),\n          excludeFromCachePatterns: toPatternSource(this.config.excludeFromCache),\n          strategies: this.config.strategies || {},\n          push: {\n            enabled: this.config.push.enabled,\n            publicKey: this.config.push.publicKey,\n            userVisibleOnly: this.config.push.userVisibleOnly\n          }\n        }\n      });\n      this.log('Sent config to service worker');\n    } catch (error) {\n      this.handleError(error, 'updateConfig');\n    }\n  },\n\n  /**\n   * Check if Service Workers and Push Notifications are supported in the current browser\n   * @returns {Boolean}\n   */\n  isSupported() {\n    return 'serviceWorker' in navigator && 'PushManager' in window;\n  },\n\n  /**\n   * Register the service worker\n   * @private\n   */\n  async registerServiceWorker() {\n    try {\n      this.state.status = 'registering';\n      this.log('Registering service worker');\n      const registration = await navigator.serviceWorker.register(\n        this.config.serviceWorkerPath,\n        {scope: this.config.scope}\n      );\n      this.state.registration = registration;\n      this.state.status = 'registered';\n      this.log('Service worker registered successfully');\n      this.setupEventListeners(registration);\n      this.checkForUpdates(registration);\n      EventManager.emit('serviceworker:registered', {registration});\n      return registration;\n    } catch (error) {\n      this.state.status = 'failed';\n      this.handleError(error);\n      throw error;\n    }\n  },\n\n  /**\n   * Sets up push notifications if they are enabled in the configuration and supported by the browser.\n   * This method checks for an existing push subscription and updates the state accordingly.\n   * @async\n   * @returns {Promise<void>} A promise that resolves when the push notification setup is complete\n   * @throws {Error} If there's an error during push notification setup\n   */\n  async setupPushNotifications() {\n    if (!this.config.push.enabled || !this.state.registration) return;\n    if (!('PushManager' in window)) {\n      this.log('Push Notifications are not supported in this browser');\n      return;\n    }\n    try {\n      const subscription = await this.state.registration.pushManager.getSubscription();\n      if (subscription) {\n        this.state.pushEnabled = true;\n        this.state.pushSubscription = subscription;\n        this.log('Push notifications already subscribed');\n      }\n    } catch (error) {\n      this.handleError(error, 'pushSetup');\n    }\n  },\n\n  /**\n   * Subscribes to push notifications using the service worker's push manager.\n   * Requires a configured service worker and a valid public key for push notifications.\n   * @async\n   * @throws {Error} If push is not configured or no active service worker exists\n   * @returns {Promise<PushSubscription>} The push notification subscription object\n   */\n  async subscribePush() {\n    if (!this.state.registration || !this.config.push.publicKey) {\n      throw new Error('Push not configured or no active service worker');\n    }\n    try {\n      const subscription = await this.state.registration.pushManager.subscribe({\n        userVisibleOnly: this.config.push.userVisibleOnly,\n        applicationServerKey: this.config.push.publicKey\n      });\n      this.state.pushEnabled = true;\n      this.state.pushSubscription = subscription;\n      this.log('Subscribed to push notifications');\n      EventManager.emit('serviceworker:push-subscribed', {subscription});\n      return subscription;\n    } catch (error) {\n      this.handleError(error, 'pushSubscribe');\n      throw error;\n    }\n  },\n\n  /**\n   * Unsubscribes from push notifications by removing the existing push subscription.\n   * @async\n   * @returns {Promise<boolean>} Returns true if successfully unsubscribed, false if no subscription existed\n   * @throws {Error} If unsubscription fails\n   */\n  async unsubscribePush() {\n    try {\n      const subscription = await this.state.registration.pushManager.getSubscription();\n      if (subscription) {\n        await subscription.unsubscribe();\n        this.state.pushEnabled = false;\n        this.state.pushSubscription = null;\n        this.log('Unsubscribed from push notifications');\n        EventManager.emit('serviceworker:push-unsubscribed');\n        return true;\n      }\n      return false;\n    } catch (error) {\n      this.handleError(error, 'pushUnsubscribe');\n      throw error;\n    }\n  },\n\n  /**\n   * Checks if push notifications are enabled for this service worker instance.\n   * @returns {boolean} True if push notifications are enabled, false otherwise\n   */\n  isPushEnabled() {\n    return this.state.pushEnabled;\n  },\n\n  /**\n   * Set up event listeners for the service worker\n   * @param {ServiceWorkerRegistration} registration\n   * @private\n   */\n  setupEventListeners(registration) {\n    registration.addEventListener('updatefound', () => {\n      this.state.updateFound = true;\n      this.state.installingWorker = registration.installing;\n      if (this.state.installingWorker) {\n        this.state.installingWorker.addEventListener('statechange', () => {\n          this.handleStateChange(this.state.installingWorker);\n        });\n      }\n      this.log('New service worker found and is installing');\n      EventManager.emit('serviceworker:update-found', {registration});\n    });\n\n    navigator.serviceWorker.addEventListener('controllerchange', () => {\n      if (this.state.updateFound) {\n        this.log('New service worker activated');\n        this.showUpdateNotification();\n      }\n    });\n\n    navigator.serviceWorker.addEventListener('message', (event) => {\n      this.handleWorkerMessage(event);\n    });\n  },\n\n  /**\n   * Handle service worker state changes\n   * @param {ServiceWorker} worker - The service worker instance\n   * @private\n   */\n  handleStateChange(worker) {\n    this.log(`Service worker state changed to: ${worker.state}`);\n    switch (worker.state) {\n      case 'installed':\n        if (navigator.serviceWorker.controller) {\n          this.log('New content is available; please refresh.');\n          this.state.status = 'updated';\n          if (this.config.notifyOnUpdate) {\n            this.showUpdateNotification();\n          }\n        } else {\n          this.log('Content is now cached for offline use.');\n          this.state.status = 'installed';\n          this.state.offlineReady = true;\n        }\n        break;\n      case 'activated':\n        this.state.status = 'activated';\n        this.log('Service worker activated and controlling the page');\n        break;\n      case 'redundant':\n        this.state.status = 'redundant';\n        this.log('The installing service worker became redundant');\n        break;\n    }\n    EventManager.emit('serviceworker:state-change', {state: worker.state, status: this.state.status});\n  },\n\n  /**\n   * Notify user about service worker update\n   * @private\n   */\n  showUpdateNotification() {\n    if (!this.config.notifyOnUpdate) return;\n    if (window.NotificationManager) {\n      NotificationManager.info('A new version is available. Refresh the page to update.', {\n        duration: 0,\n        id: 'sw-update',\n        actions: [{\n          label: 'Refresh',\n          callback: () => window.location.reload()\n        }]\n      });\n    } else {\n      this.log('A new version is available. Refresh the page to update.', 'info');\n    }\n  },\n\n  /**\n   * Check for service worker updates\n   * @param {ServiceWorkerRegistration} registration\n   * @private\n   */\n  async checkForUpdates(registration) {\n    try {\n      this.log('Checking for service worker updates');\n      this.state.lastUpdateCheck = Date.now();\n      await registration.update();\n      this.log('Update check completed');\n    } catch (error) {\n      this.handleError(error);\n    }\n  },\n\n  /**\n   * Set up periodic update checks\n   * @private\n   */\n  setupUpdateChecks() {\n    if (!this.config.updateInterval) return;\n    window.addEventListener('online', () => {\n      this.log('Network connection restored, checking for updates');\n      if (this.state.registration) {\n        this.checkForUpdates(this.state.registration);\n      }\n    });\n    setInterval(() => {\n      if (navigator.onLine && this.state.registration) {\n        this.log('Performing scheduled update check');\n        this.checkForUpdates(this.state.registration);\n      }\n    }, this.config.updateInterval);\n  },\n\n  /**\n   * Handle messages from the service worker\n   * @param {MessageEvent} event\n   * @private\n   */\n  handleWorkerMessage(event) {\n    const data = event.data;\n    if (!data || !data.type) return;\n    this.log(`Received message from service worker: ${data.type}`, 'debug');\n    switch (data.type) {\n      case 'CACHE_UPDATED':\n        this.log(`Cache updated: ${data.payload.cacheName}`);\n        break;\n      case 'CACHE_ERROR':\n        this.handleError(new Error(data.payload.message), 'cache');\n        break;\n      case 'OFFLINE_READY':\n        this.state.offlineReady = true;\n        this.log('Application is ready for offline use');\n        EventManager.emit('serviceworker:offline-ready');\n        break;\n      case 'LOG':\n        this.log(`[SW] ${data.payload.message}`, data.payload.level);\n        break;\n      case 'PUSH_SUBSCRIPTION':\n        this.state.pushSubscription = data.payload;\n        this.state.pushEnabled = true;\n        this.log('Push subscription updated from worker');\n        break;\n      case 'CONFIG_UPDATED':\n        this.log('Service worker confirmed config update');\n        break;\n    }\n    EventManager.emit('serviceworker:message', data);\n  },\n\n  /**\n   * Log a message if debug is enabled\n   * @param {String} message - The message to log\n   * @param {String} level - Log level (default: 'log')\n   * @private\n   */\n  log(message, level = 'log') {\n    if (!this.config.debug) return;\n    const prefix = '[ServiceWorkerManager]';\n    switch (level) {\n      case 'error':\n        console.error(prefix, message);\n        break;\n      case 'warn':\n        console.warn(prefix, message);\n        break;\n      case 'info':\n        console.info(prefix, message);\n        break;\n      default:\n        console.log(prefix, message);\n    }\n  },\n\n  /**\n   * Handle errors in ServiceWorkerManager\n   * @param {Error} error - The error object\n   * @param {String} context - Optional context string\n   * @private\n   */\n  handleError(error, context = 'general') {\n    const errorInfo = {\n      message: error.message,\n      stack: error.stack,\n      context,\n      timestamp: Date.now()\n    };\n    this.state.errors.push(errorInfo);\n    this.log(`Error (${context}): ${error.message}`, 'error');\n    if (window.ErrorManager) {\n      ErrorManager.handle(error, {\n        context: `ServiceWorkerManager.${context}`,\n        type: 'error:serviceworker',\n        data: errorInfo\n      });\n    }\n    EventManager.emit('serviceworker:error', errorInfo);\n  },\n\n  /**\n   * Manually request caching of specific URLs\n   * @param {Array<String>} urls - Array of URLs to cache\n   * @returns {Promise<Boolean>} Success status\n   */\n  async cacheUrls(urls) {\n    if (!this.state.registration || !urls || !Array.isArray(urls)) return false;\n    try {\n      const sw = this.state.registration.active;\n      if (!sw) throw new Error('No active service worker found');\n      sw.postMessage({type: 'CACHE_URLS', payload: {urls}});\n      return true;\n    } catch (error) {\n      this.handleError(error, 'cacheUrls');\n      return false;\n    }\n  },\n\n  /**\n   * Clear the service worker cache\n   * @returns {Promise<Boolean>} Success status\n   */\n  async clearCache() {\n    if (!this.state.registration) return false;\n    try {\n      const sw = this.state.registration.active;\n      if (!sw) throw new Error('No active service worker found');\n      sw.postMessage({type: 'CLEAR_CACHE'});\n      return true;\n    } catch (error) {\n      this.handleError(error, 'clearCache');\n      return false;\n    }\n  },\n\n  /**\n   * Force update the service worker\n   * @returns {Promise<Boolean>} Success status\n   */\n  async update() {\n    if (!this.state.registration) return false;\n    try {\n      await this.state.registration.update();\n      return true;\n    } catch (error) {\n      this.handleError(error, 'update');\n      return false;\n    }\n  },\n\n  /**\n   * Force service worker to skip waiting and activate\n   * @returns {Promise<Boolean>} Success status\n   */\n  async skipWaiting() {\n    if (!this.state.registration || !this.state.installingWorker) return false;\n    try {\n      this.state.installingWorker.postMessage({type: 'SKIP_WAITING'});\n      return true;\n    } catch (error) {\n      this.handleError(error, 'skipWaiting');\n      return false;\n    }\n  },\n\n  /**\n   * Check if the application is ready for offline use\n   * @returns {Boolean}\n   */\n  isOfflineReady() {\n    return this.state.offlineReady;\n  },\n\n  /**\n   * Get status information about the service worker\n   * @returns {Object} Status information\n   */\n  getStatus() {\n    return {\n      supported: this.isSupported(),\n      initialized: this.state.initialized,\n      status: this.state.status,\n      offlineReady: this.state.offlineReady,\n      registration: this.state.registration,\n      lastUpdateCheck: this.state.lastUpdateCheck,\n      errors: this.state.errors.length,\n      pushEnabled: this.state.pushEnabled\n    };\n  },\n\n  /**\n   * Unregister the service worker\n   * @returns {Promise<Boolean>} Success status\n   */\n  async unregister() {\n    if (!this.state.registration) return false;\n    try {\n      const success = await this.state.registration.unregister();\n      if (success) {\n        this.log('Service worker unregistered successfully');\n        this.state.registration = null;\n        this.state.status = 'unregistered';\n        this.state.offlineReady = false;\n        EventManager.emit('serviceworker:unregistered');\n      }\n      return success;\n    } catch (error) {\n      this.handleError(error, 'unregister');\n      return false;\n    }\n  }\n};\n\nif (window.Now?.registerManager) {\n  Now.registerManager('serviceWorker', ServiceWorkerManager);\n}\nwindow.ServiceWorkerManager = ServiceWorkerManager;\n"],"names":["ServiceWorkerManager","config","enabled","serviceWorkerPath","scope","version","cacheName","debug","updateInterval","precache","cacheJavascriptFiles","cachePatterns","networkFirst","excludeFromCache","notifyOnUpdate","offlineContent","push","publicKey","userVisibleOnly","strategies","state","initialized","registration","updateFound","installingWorker","offlineReady","lastUpdateCheck","status","errors","pushEnabled","pushSubscription","init","options","this","isSupported","registerServiceWorker","setupUpdateChecks","setupPushNotifications","updateConfig","log","error","handleError","sw","active","Promise","resolve","checkActive","setTimeout","addEventListener","worker","installing","Error","toPatternSource","arr","map","p","RegExp","source","postMessage","type","payload","precacheUrls","networkFirstPatterns","excludeFromCachePatterns","navigator","window","serviceWorker","register","setupEventListeners","checkForUpdates","EventManager","emit","subscription","pushManager","getSubscription","subscribePush","subscribe","applicationServerKey","unsubscribePush","unsubscribe","isPushEnabled","handleStateChange","showUpdateNotification","event","handleWorkerMessage","controller","NotificationManager","info","duration","id","actions","label","callback","location","reload","Date","now","update","setInterval","onLine","data","message","level","prefix","console","warn","context","errorInfo","stack","timestamp","ErrorManager","handle","cacheUrls","urls","Array","isArray","clearCache","skipWaiting","isOfflineReady","getStatus","supported","length","unregister","success","_a","Now","registerManager"],"mappings":"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"}