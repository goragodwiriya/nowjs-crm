!function(){"use strict";var e;const t={config:{debug:!1,enabled:!1,defaultConcurrency:5,defaultMaxRetries:3,defaultRetryDelay:1e3,defaultBackoffStrategy:"exponential",defaultTimeout:3e4,persistence:{enabled:!1,storeName:"queued_tasks",syncInterval:5e3,maxPersistedTasks:1e3},rateLimiting:{enabled:!1,limit:10,interval:1e3,fairness:!0},workerPool:{enabled:!0,size:navigator.hardwareConcurrency||4,idleTimeout:6e4}},state:{initialized:!1,enabled:!1,queues:new Map,workers:[],activeWorkers:0,runningTasks:new Map,taskCounter:0,persistenceTimer:null,rateLimitCounter:0,rateLimitResetTime:0,pausedQueues:new Set,statistics:{processed:0,succeeded:0,failed:0,retried:0,avgProcessingTime:0}},async init(e={}){var t;try{if(this.config={...this.config,...e},this.config.persistence.enabled)if(this.storageManager=null==(t=window.Now)?void 0:t.getManager("storage"),this.storageManager){if(!this.storageManager.state.initialized)try{await this.storageManager.init()}catch(s){console.error("Failed to initialize StorageManager:",s),console.warn("StorageManager initialization failed, persistence disabled"),this.config.persistence.enabled=!1}if(this.config.persistence.enabled)try{await this.storageManager.createDatabase({name:this.storageManager.config.defaultDB,version:this.storageManager.config.defaultVersion,stores:{[this.config.persistence.storeName]:{keyPath:"id",autoIncrement:!0,indexes:[{name:"queueName",keyPath:"queueName"},{name:"priority",keyPath:"priority"},{name:"scheduledTime",keyPath:"scheduledTime"}]}}}),await this.loadPersistedTasks()}catch(a){console.error("Failed to create database for QueueManager:",a),console.warn("Queue persistence setup failed, persistence disabled"),this.config.persistence.enabled=!1}}else console.warn("StorageManager not found, persistence disabled"),this.config.persistence.enabled=!1;return this.config.workerPool.enabled&&this.initWorkerPool(),this.state.initialized=!0,EventManager.emit("queue:ready",{manager:"QueueManager"}),this}catch(i){throw console.error("QueueManager initialization failed:",i),window.ErrorManager&&ErrorManager.handle(i,{context:"QueueManager.init",type:"queue:error"}),i}},async enable(){this.state.initialized||await this.init(),this.state.enabled=!0,this.config.enabled=!0,this.config.persistence.enabled&&this.startPersistenceSync();for(const e of this.state.queues.keys())this.processNextTasks(e);return EventManager.emit("queue:enabled"),this},disable(){return this.state.enabled=!1,this.config.enabled=!1,this.state.persistenceTimer&&(clearInterval(this.state.persistenceTimer),this.state.persistenceTimer=null),this.state.workers.forEach(e=>{e.busy=!1,e.task=null}),EventManager.emit("queue:disabled"),this},createQueue(e,t={}){if(this.state.queues.has(e))return this.config.debug&&console.warn(`Queue "${e}" already exists`),this.getQueue(e);const s={name:e,tasks:[],options:{concurrency:this.config.defaultConcurrency,maxRetries:this.config.defaultMaxRetries,retryDelay:this.config.defaultRetryDelay,backoffStrategy:this.config.defaultBackoffStrategy,timeout:this.config.defaultTimeout,priority:!1,fifo:!0,paused:!1,...t},activeTasks:0,isProcessing:!1};return this.state.queues.set(e,s),EventManager.emit("queue:created",{name:e,options:s.options}),this.getQueueInterface(e)},getQueue(e){if(!this.state.queues.has(e))throw new Error(`Queue "${e}" does not exist`);return this.getQueueInterface(e)},getQueueInterface(e){return{add:(t,s)=>this.addTask(e,t,s),addBulk:(t,s)=>this.addBulkTasks(e,t,s),pause:()=>this.pauseQueue(e),resume:()=>this.resumeQueue(e),clear:()=>this.clearQueue(e),getStats:()=>this.getQueueStats(e),getLength:()=>this.getQueueLength(e),setPriority:t=>this.setQueuePriority(e,t),setConcurrency:t=>this.setQueueConcurrency(e,t),getName:()=>e,isPaused:()=>this.isQueuePaused(e),isEnabled:()=>this.config.enabled&&this.state.enabled}},addTask(e,t,s={}){if(!this.config.enabled||!this.state.enabled)throw new Error("QueueManager is disabled");if(!this.state.initialized)throw new Error("QueueManager is not initialized");this.state.queues.has(e)||this.createQueue(e);const a=this.state.queues.get(e),i=`task_${++this.state.taskCounter}_${Date.now()}`,r="function"==typeof t,n={id:i,queueName:e,callback:r?t:null,data:r?null:t,priority:void 0!==s.priority?s.priority:0,scheduledTime:s.delay?Date.now()+s.delay:Date.now(),attempts:0,maxRetries:void 0!==s.maxRetries?s.maxRetries:a.options.maxRetries,retryDelay:void 0!==s.retryDelay?s.retryDelay:a.options.retryDelay,backoffStrategy:s.backoffStrategy||a.options.backoffStrategy,timeout:void 0!==s.timeout?s.timeout:a.options.timeout,createdAt:Date.now()};return a.tasks.push(n),a.options.priority&&this.sortQueueByPriority(a),!s.delay&&!a.options.paused&&a.activeTasks<a.options.concurrency&&this.processNextTasks(e),this.config.persistence.enabled&&this.storageManager&&this.persistTask(n),EventManager.emit("queue:task:added",{queueName:e,taskId:i,scheduled:s.delay?new Date(n.scheduledTime):new Date}),i},addBulkTasks(e,t,s={}){if(!Array.isArray(t))throw new Error("Tasks must be an array");return t.map(t=>this.addTask(e,t,s))},sortQueueByPriority(e){e.tasks.sort((e,t)=>e.priority!==t.priority?e.priority-t.priority:e.scheduledTime-t.scheduledTime)},async processNextTasks(e){if(!this.config.enabled||!this.state.enabled)return;if(!this.state.queues.has(e))return;const t=this.state.queues.get(e);if(t.options.paused||t.activeTasks>=t.options.concurrency)return;const s=Date.now(),a=t.tasks.filter(e=>e.scheduledTime<=s);if(0===a.length)return;if(this.config.rateLimiting.enabled&&(s>this.state.rateLimitResetTime&&(this.state.rateLimitCounter=0,this.state.rateLimitResetTime=s+this.config.rateLimiting.interval),this.state.rateLimitCounter>=this.config.rateLimiting.limit))return void setTimeout(()=>{this.processNextTasks(e)},this.state.rateLimitResetTime-s);const i=Math.min(a.length,t.options.concurrency-t.activeTasks);if(!(i<=0)){this.config.rateLimiting.enabled&&(this.state.rateLimitCounter+=i);for(let e=0;e<i;e++){const e=t.tasks.findIndex(e=>e.scheduledTime<=s);if(-1===e)break;const a=t.tasks.splice(e,1)[0];this.config.workerPool.enabled?(t.activeTasks++,this.submitTaskToWorkerPool(a)):this.processTask(a)}}},async processTask(e){const t=this.state.queues.get(e.queueName);if(!t)return;t.activeTasks++,this.state.runningTasks.set(e.id,e);const s=setTimeout(()=>{this.handleTaskTimeout(e)},e.timeout),a=performance.now();try{let t;EventManager.emit("queue:task:started",{queueName:e.queueName,taskId:e.id,attempt:e.attempts+1}),e.attempts++,t=e.callback?await Promise.resolve(e.callback(e.data)):e.data&&e.data.url?await this.executeApiTask(e):await this.executeEventTask(e),clearTimeout(s),await this.handleTaskSuccess(e,t,performance.now()-a)}catch(i){clearTimeout(s),await this.handleTaskError(e,i,performance.now()-a)}finally{this.state.runningTasks.delete(e.id),t.activeTasks--,this.processNextTasks(e.queueName)}},async executeApiTask(e){var t,s;const{url:a,method:i="GET",data:r,headers:n={}}=e.data,o=i.toLowerCase(),u=window.ApiService||(null==(s=null==(t=window.Now)?void 0:t.getManager)?void 0:s.call(t,"api"));if(u&&"function"==typeof u[o])return u[o](a,r,{headers:n});if(window.http&&"function"==typeof window.http[o])return window.http[o](a,r,{headers:n});if(window.simpleFetch&&"function"==typeof window.simpleFetch[o])return window.simpleFetch[o](a,r,{headers:n});throw new Error("No HTTP client available to execute API task")},async executeEventTask(e){const{event:t,data:s}=e.data||{};if(!t)throw new Error("Event name is required for event tasks");return EventManager.emit(t,s||{})},async handleTaskTimeout(e){const t=new Error(`Task ${e.id} timed out after ${e.timeout}ms`);await this.handleTaskError(e,t,e.timeout)},async handleTaskSuccess(e,t,s){this.state.statistics.processed++,this.state.statistics.succeeded++;const a=this.state.statistics.processed;this.state.statistics.avgProcessingTime=(this.state.statistics.avgProcessingTime*(a-1)+s)/a,this.config.persistence.enabled&&this.storageManager&&await this.removePersistedTask(e),EventManager.emit("queue:task:completed",{queueName:e.queueName,taskId:e.id,executionTime:s,result:t})},async handleTaskError(e,t,s){if(this.state.statistics.processed++,e.attempts<=e.maxRetries){let s=e.retryDelay;"exponential"===e.backoffStrategy?s=e.retryDelay*Math.pow(2,e.attempts-1):"linear"===e.backoffStrategy&&(s=e.retryDelay*e.attempts),e.scheduledTime=Date.now()+s;const a=this.state.queues.get(e.queueName);a.tasks.push(e),a.options.priority&&this.sortQueueByPriority(a),this.state.statistics.retried++,EventManager.emit("queue:task:retrying",{queueName:e.queueName,taskId:e.id,attempt:e.attempts,nextAttempt:new Date(e.scheduledTime),error:{message:t.message,stack:t.stack}})}else this.state.statistics.failed++,this.config.persistence.enabled&&this.storageManager&&await this.removePersistedTask(e),EventManager.emit("queue:task:failed",{queueName:e.queueName,taskId:e.id,attempts:e.attempts,executionTime:s,error:{message:t.message,stack:t.stack}}),window.ErrorManager?ErrorManager.handle(t,{context:`QueueManager.processTask(${e.queueName})`,type:"queue:task:error",data:{taskId:e.id,queueName:e.queueName,attempts:e.attempts}}):this.config.debug&&console.error(`Task ${e.id} in queue ${e.queueName} failed after ${e.attempts} attempts:`,t)},pauseQueue(e){if(!this.state.queues.has(e))return!1;return this.state.queues.get(e).options.paused=!0,this.state.pausedQueues.add(e),EventManager.emit("queue:paused",{queueName:e}),!0},resumeQueue(e){if(!this.state.queues.has(e))return!1;return this.state.queues.get(e).options.paused=!1,this.state.pausedQueues.delete(e),this.config.enabled&&this.state.enabled&&this.processNextTasks(e),EventManager.emit("queue:resumed",{queueName:e}),!0},isQueuePaused(e){return!!this.state.queues.has(e)&&this.state.queues.get(e).options.paused},clearQueue(e){if(!this.state.queues.has(e))return 0;const t=this.state.queues.get(e),s=t.tasks.length;return t.tasks=[],this.config.persistence.enabled&&this.storageManager&&this.storageManager.deleteByQuery(this.config.persistence.storeName,{index:"queueName",value:e}).catch(t=>{console.error(`Failed to clear persisted tasks for queue ${e}:`,t)}),EventManager.emit("queue:cleared",{queueName:e,taskCount:s}),s},getQueueStats(e){if(!this.state.queues.has(e))return null;const t=this.state.queues.get(e),s=Date.now();return{name:e,length:t.tasks.length,activeTasks:t.activeTasks,paused:t.options.paused,enabled:this.config.enabled&&this.state.enabled,ready:t.tasks.filter(e=>e.scheduledTime<=s).length,scheduled:t.tasks.filter(e=>e.scheduledTime>s).length,concurrency:t.options.concurrency,priority:t.options.priority,oldestTask:t.tasks.length>0?new Date(Math.min(...t.tasks.map(e=>e.createdAt))):null}},getQueueLength(e){return this.state.queues.has(e)?this.state.queues.get(e).tasks.length:0},setQueuePriority(e,t){if(!this.state.queues.has(e))return!1;const s=this.state.queues.get(e);return s.options.priority=!!t,s.options.priority&&this.sortQueueByPriority(s),!0},setQueueConcurrency(e,t){if(!this.state.queues.has(e))return!1;if("number"!=typeof t||t<1)throw new Error("Concurrency must be a positive number");return this.state.queues.get(e).options.concurrency=t,this.config.enabled&&this.state.enabled&&this.processNextTasks(e),!0},async persistTask(e){if(this.config.persistence.enabled&&this.storageManager)try{if(e.callback)return;const t={id:e.id,queueName:e.queueName,data:e.data,priority:e.priority,scheduledTime:e.scheduledTime,attempts:e.attempts,maxRetries:e.maxRetries,retryDelay:e.retryDelay,backoffStrategy:e.backoffStrategy,timeout:e.timeout,createdAt:e.createdAt};await this.storageManager.add(this.config.persistence.storeName,t)}catch(t){console.error("Failed to persist task:",t)}},async removePersistedTask(e){if(this.config.persistence.enabled&&this.storageManager)try{await this.storageManager.delete(this.config.persistence.storeName,e.id)}catch(t){this.config.debug&&console.warn("Failed to remove persisted task:",t)}},startPersistenceSync(){this.config.persistence.enabled&&this.storageManager&&(this.state.persistenceTimer&&clearInterval(this.state.persistenceTimer),this.state.persistenceTimer=setInterval(()=>{this.syncPersistedTasks()},this.config.persistence.syncInterval))},async syncPersistedTasks(){if(this.config.persistence.enabled&&this.storageManager)try{for(const[t,s]of this.state.queues.entries()){const e=s.tasks.filter(e=>!e.callback&&!e._persisted);for(const t of e)await this.persistTask(t),t._persisted=!0}const e=await this.storageManager.count(this.config.persistence.storeName);if(e>this.config.persistence.maxPersistedTasks){const t=e-this.config.persistence.maxPersistedTasks,s=await this.storageManager.getAll(this.config.persistence.storeName,{index:"createdAt",direction:"asc",limit:t});for(const e of s)await this.storageManager.delete(this.config.persistence.storeName,e.id)}}catch(e){console.error("Failed to sync persisted tasks:",e)}},async loadPersistedTasks(){if(!this.config.persistence.enabled||!this.storageManager)return 0;try{const e=await this.storageManager.getAll(this.config.persistence.storeName);if(0===e.length)return 0;let t=0;for(const s of e){this.state.queues.has(s.queueName)||this.createQueue(s.queueName);this.state.queues.get(s.queueName).tasks.push({...s,_persisted:!0}),t++}for(const s of this.state.queues.values())s.options.priority&&this.sortQueueByPriority(s);if(this.config.enabled&&this.state.enabled)for(const s of this.state.queues.keys())this.processNextTasks(s);return EventManager.emit("queue:tasks:loaded",{count:t}),t}catch(e){return console.error("Failed to load persisted tasks:",e),0}},initWorkerPool(){const e=this.config.workerPool.size;this.state.workers=[];for(let t=0;t<e;t++)this.state.workers.push({id:`worker_${t}`,busy:!1,task:null,lastActive:Date.now()})},submitTaskToWorkerPool(e){const t=this.state.workers.find(e=>!e.busy);if(t)t.busy=!0,t.task=e,t.lastActive=Date.now(),this.processTaskInWorker(t);else{const t=this.state.queues.get(e.queueName);t.tasks.unshift(e),t.activeTasks--}},async processTaskInWorker(e){const t=e.task;try{await this.processTask(t)}finally{e.busy=!1,e.task=null,e.lastActive=Date.now();for(const e of this.state.queues.keys())this.processNextTasks(e)}},getGlobalStats(){const e={};let t=0,s=0,a=0;for(const[i,r]of this.state.queues.entries())t+=r.tasks.length,s+=r.activeTasks,r.options.paused&&a++,e[i]={length:r.tasks.length,active:r.activeTasks,paused:r.options.paused,concurrency:r.options.concurrency};return{enabled:this.config.enabled&&this.state.enabled,queues:e,queueCount:this.state.queues.size,pausedQueues:a,totalTasks:t,activeTasks:s,processed:this.state.statistics.processed,succeeded:this.state.statistics.succeeded,failed:this.state.statistics.failed,retried:this.state.statistics.retried,averageProcessingTime:this.state.statistics.avgProcessingTime,workers:{total:this.state.workers.length,active:this.state.workers.filter(e=>e.busy).length}}},pauseAll(){let e=0;for(const t of this.state.queues.keys())this.isQueuePaused(t)||(this.pauseQueue(t),e++);return EventManager.emit("queue:all:paused",{count:e}),e},resumeAll(){let e=0;for(const t of this.state.pausedQueues)this.resumeQueue(t),e++;return EventManager.emit("queue:all:resumed",{count:e}),e},clearAll(){let e=0;for(const t of this.state.queues.keys())e+=this.clearQueue(t);return EventManager.emit("queue:all:cleared",{count:e}),e},destroy(){this.state.persistenceTimer&&(clearInterval(this.state.persistenceTimer),this.state.persistenceTimer=null),this.clearAll(),this.state={initialized:!1,enabled:!1,queues:new Map,workers:[],activeWorkers:0,runningTasks:new Map,taskCounter:0,persistenceTimer:null,rateLimitCounter:0,rateLimitResetTime:0,pausedQueues:new Set,statistics:{processed:0,succeeded:0,failed:0,retried:0,avgProcessingTime:0}},EventManager.emit("queue:destroyed")}};(null==(e=window.Now)?void 0:e.registerManager)&&Now.registerManager("queue",t),window.QueueManager=t}();
//# sourceMappingURL=now.queue.min.js.map
