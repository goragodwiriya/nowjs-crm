{"version":3,"file":"now.graph.min.js","sources":["../js/GraphRenderer.js","../js/GraphComponent.js"],"sourcesContent":["/**\n* GraphRenderer for Now.js Framework\n* Core rendering engine for GraphComponent\n*\n* Features:\n* - Line charts\n* - Bar charts\n* - Pie charts\n* - Donut charts\n* - Gauge charts\n* - SVG based rendering\n* - Tooltips\n* - Legends\n* - Responsive design\n* - Animation support\n*/\nclass GraphRenderer {\n  /**\n   * Themes for the graph\n   */\n  themes = {\n    light: {\n      backgroundColor: '#ffffff',\n      textColor: '#333333',\n      gridColor: '#e0e0e0',\n      axisColor: '#666666'\n    },\n    dark: {\n      backgroundColor: '#2d2d2d',\n      textColor: '#ffffff',\n      gridColor: '#404040',\n      axisColor: '#808080'\n    }\n  }\n\n  /**\n   * Creates a new instance of GraphRenderer\n   * @param {HTMLElement} container - The container element for the graph\n   * @param {Object} options - Configuration options for the graph\n   */\n  constructor(container, options = {}) {\n    if (!container) {\n      throw new Error('Container element is required');\n    }\n\n    this.container = container;\n    this.width = container.clientWidth;\n    this.height = container.clientHeight;\n\n    const containerStyles = window.getComputedStyle(this.container);\n    const defaultFontSize = parseInt(containerStyles.fontSize, 10);\n    const defaultFontFamily = containerStyles.fontFamily || 'Arial, sans-serif';\n    const defaultTextColor = containerStyles.color || '#000000';\n    let defaultBackgroundColor = containerStyles.backgroundColor;\n    if (!defaultBackgroundColor || defaultBackgroundColor === 'transparent' || defaultBackgroundColor === 'rgba(0, 0, 0, 0)') {\n      defaultBackgroundColor = '#ffffff';\n    }\n\n    this.defaultConfig = {\n      colors: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F9ED69', '#F08A5D', '#B83B5E', '#6A2C70', '#00B8A9', '#F8F3D4', '#3F72AF'],\n      backgroundColor: defaultBackgroundColor,\n      showGrid: true,\n      gridColor: '#E0E0E0',\n      axisColor: '#333333',\n      curve: true,\n      maxGaugeValue: 100,\n      centerText: null,\n      showCenterText: true,\n      gap: 2,\n      borderWidth: 1,\n      borderColor: 'auto',\n      pointRadius: 4,\n      lineWidth: 2,\n      fillArea: false,\n      fillOpacity: 0.1,\n      fontFamily: defaultFontFamily,\n      textColor: defaultTextColor,\n      fontSize: isNaN(defaultFontSize) ? 16 : defaultFontSize,\n      showAxisLabels: true,\n      showAxis: true,\n      animationDuration: 1000,\n      donutThickness: 30,\n      gaugeCurveWidth: 20,\n      showLegend: true,\n      legendPosition: 'bottom',\n      showTooltip: true,\n      tooltipFormatter: null,\n      showDataLabels: true,\n      showValueInsteadOfPercent: true,\n      animation: false,\n      maxDataPoints: 20,\n      type: 'line', // line, bar, pie, donut, gauge\n      table: null,\n      data: null,\n      onClick: null,\n      fontUrl: null\n    };\n\n    this.readConfigFromDataAttributes();\n\n    this.config = {...this.defaultConfig, ...options, ...this.configFromData};\n\n    this.data = [];\n    this.minValue = 0;\n    this.maxValue = 0;\n    this.currentChartType = this.config.type;\n    this.legend = null;\n    this.state = {\n      initialized: false,\n    };\n\n    this.validateOptions(this.config);\n\n    this.calculateFontSize();\n    this.setMargins();\n    this.visibleDataCount = this.calculateVisibleDataCount();\n\n    if (this.config.table) {\n      this.createSVG();\n      this.initialize();\n    } else if (this.config.data) {\n      this.createSVG();\n      this.setData(this.config.data);\n      this.renderGraph();\n    }\n\n    if (this.svg) {\n      this.handleResize = this.debounce(this.handleResize.bind(this), 200);\n      window.addEventListener('resize', this.handleResize);\n    }\n\n    this.state.initialized = true;\n  }\n\n  /**\n   * Reads configuration options from data-* attributes in the container\n   */\n  readConfigFromDataAttributes() {\n    const dataAttributes = this.container.dataset;\n    this.configFromData = {};\n\n    for (const key in dataAttributes) {\n      if (dataAttributes.hasOwnProperty(key)) {\n        const configKey = this.kebabToCamel(key);\n\n        const value = this.parseConfigValue(dataAttributes[key]);\n\n        this.configFromData[configKey] = value;\n      }\n    }\n  }\n\n  /**\n   * Converts a kebab-case string to camelCase\n   * @param {string} str - The string in kebab-case\n   * @returns {string} The converted camelCase string\n   */\n  kebabToCamel(str) {\n    return str.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase());\n  }\n\n  /**\n   * Parses a configuration value from a data attribute string\n   * @param {string} value - The value to parse\n   * @returns {*} The parsed value in the appropriate data type\n   */\n  parseConfigValue(value) {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n\n    if (!isNaN(value)) return Number(value);\n\n    try {\n      return JSON.parse(value);\n    } catch (e) {\n      return value;\n    }\n  }\n\n  /**\n   * Validates the provided configuration object\n   * @param {Object} config - The configuration object to validate\n   */\n  validateOptions(config) {\n    if (config.colors && !Array.isArray(config.colors)) {\n      throw new TypeError('Option \"colors\" must be an array.');\n    }\n    if (typeof config.showGrid !== 'boolean') {\n      throw new TypeError('Option \"showGrid\" must be a boolean.');\n    }\n    if (typeof config.legendPosition !== 'string') {\n      throw new TypeError('Option \"legendPosition\" must be a string.');\n    }\n    if (typeof config.maxGaugeValue !== 'number') {\n      throw new TypeError('Option \"maxGaugeValue\" must be a number.');\n    }\n  }\n\n  /**\n   * Creates an SVG element and appends it to the container\n   */\n  createSVG() {\n    if (this.width > 0 && this.height > 0) {\n      this.svg = this.createSVGElement('svg', {\n        width: '100%',\n        height: '100%',\n        viewBox: `0 0 ${this.width} ${this.height}`,\n        role: 'img',\n        'aria-label': 'Data Visualization Graph',\n        tabindex: '0'\n      });\n\n      this.svg.addEventListener('keydown', this.handleKeyboardNavigation.bind(this));\n\n      const desc = this.createSVGElement('desc');\n      desc.textContent = this.getAccessibilityDescription();\n      this.svg.appendChild(desc);\n      this.container.appendChild(this.svg);\n    }\n  }\n\n  /**\n   * Handles keyboard navigation for the graph\n   * @param {KeyboardEvent} event - The keyboard event\n   */\n  handleKeyboardNavigation(event) {\n    switch (event.key) {\n      case 'ArrowRight':\n        break;\n      case 'ArrowLeft':\n        break;\n    }\n  }\n\n  /**\n   * Generates a meaningful description for the graph\n   * @returns {string} The description of the graph\n   */\n  getAccessibilityDescription() {\n    if (this.data && this.data.length > 0) {\n      return `Graph showing ${this.data.length} data series with values ranging from ${this.minValue} to ${this.maxValue}`;\n    } else {\n      return `Graph showing 0 data series`;\n    }\n  }\n\n  /**\n   * Creates an SVG element with the specified attributes\n   * @param {string} type - The type of SVG element to create\n   * @param {Object} [attributes={}] - The attributes to set on the SVG element\n   * @returns {SVGElement} The created SVG element\n   */\n  createSVGElement(type, attributes = {}) {\n    const elem = document.createElementNS('http://www.w3.org/2000/svg', type);\n    Object.keys(attributes).forEach(attr => elem.setAttribute(attr, attributes[attr]));\n    return elem;\n  }\n\n  /**\n   * Clears the existing SVG content and creates a new SVG element\n   */\n  clear() {\n    if (this.svg && this.container.contains(this.svg)) {\n      this.container.removeChild(this.svg);\n    }\n    this.createSVG();\n  }\n\n  /**\n   * Creates a debounced version of the provided function\n   * @param {Function} func - The function to debounce\n   * @param {number} wait - The debounce interval in milliseconds\n   * @returns {Function} The debounced function\n   */\n  debounce(func, wait) {\n    let timeout;\n    return (...args) => {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => func.apply(this, args), wait);\n    };\n  }\n\n  /**\n   * Calculates and sets the font size based on the container dimensions\n   */\n  calculateFontSize() {\n    if (this.config?.fontSize) {\n      if (this.config?.type === 'gauge') {\n        this.config.labelFontSize = this.config.fontSize * 0.5;\n      } else {\n        const minDimension = Math.min(this.width, this.height);\n        if (minDimension > 0) {\n          this.config.fontSize = Math.max(10, Math.min(this.config.fontSize, minDimension / 20));\n          this.config.labelFontSize = this.config.fontSize * 0.8;\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculates the number of visible data points based on the configuration\n   * @returns {number} The number of visible data points\n   */\n  calculateVisibleDataCount() {\n    if (!this.data || this.data.length === 0 || !this.data[0].data) {\n      return 0;\n    }\n    if (this.config.maxDataPoints === 0) {\n      return this.data[0].data.length;\n    }\n    return Math.min(this.config.maxDataPoints, this.data[0].data.length);\n  }\n\n  /**\n   * Handles window resize events by updating dimensions and redrawing the graph\n   */\n  handleResize() {\n    const newWidth = this.container.clientWidth;\n    const newHeight = this.container.clientHeight;\n\n    // Only redraw if container has actual dimensions\n    if (newWidth === 0 || newHeight === 0) {\n      if (!this._waitingForSize) {\n        this._waitingForSize = true;\n        setTimeout(() => {\n          this._waitingForSize = false;\n          this.handleResize();\n        }, 100);\n      }\n      return;\n    }\n\n    this.width = newWidth;\n    this.height = newHeight;\n\n    if (this.svg && this.width > 0 && this.height > 0) {\n      this.svg.setAttribute('viewBox', `0 0 ${this.width} ${this.height}`);\n      this.calculateFontSize();\n      this.setMargins();\n      this.visibleDataCount = this.calculateVisibleDataCount();\n      this.redrawGraph();\n    }\n  }\n\n  /**\n   * Loads and processes data from an HTML table\n   * @param {HTMLTableElement} table - The table element to load data from\n   * @returns {Array} The processed series data\n   */\n  loadAndProcessTableData(table) {\n    const tableData = this.loadFromTable(table);\n    return this.processTableData(tableData);\n  }\n\n  /**\n   * Loads raw data from an HTML table\n   * @param {HTMLTableElement} table - The table element to load data from\n   * @returns {Object} The raw table data\n   */\n  loadFromTable(table) {\n    const rawData = {\n      headers: {\n        title: '',\n        items: []\n      },\n      rows: []\n    };\n\n    const headerCells = table.querySelectorAll('thead > tr:first-child > th');\n    headerCells.forEach((cell, index) => {\n      if (index === 0) {\n        rawData.headers.title = cell.textContent.trim();\n      } else {\n        rawData.headers.items.push(cell.innerHTML);\n      }\n    });\n\n    const bodyRows = table.querySelectorAll('tbody > tr');\n    bodyRows.forEach(tr => {\n      const row = {\n        title: '',\n        items: []\n      };\n      const cells = tr.querySelectorAll('th, td');\n      cells.forEach((cell, index) => {\n        if (cell.tagName === 'TH') {\n          row.title = cell.textContent.trim();\n        } else {\n          const value = parseFloat(cell.textContent.replace(/,/g, ''));\n          row.items.push(value);\n        }\n      });\n      rawData.rows.push(row);\n    });\n\n    return rawData;\n  }\n\n  /**\n   * Processes raw table data into a series data format suitable for the graph\n   * @param {Object} rawData - The raw table data\n   * @returns {Array} The processed series data\n   */\n  processTableData(rawData) {\n    const processedData = [];\n\n    rawData.rows.forEach((row, rowIndex) => {\n      const series = {\n        name: row.title,\n        data: []\n      };\n\n      rawData.headers.items.forEach((header, colIndex) => {\n        const value = row.items[colIndex];\n        series.data.push({\n          label: header,\n          value: value,\n          tooltip: `${row.title} ${header}: ${this.formatValue(value)}`\n        });\n      });\n\n      processedData.push(series);\n    });\n\n    return processedData;\n  }\n\n  /**\n   * Sets the data for the graph and updates the range\n   * @param {Array} data - The data to set\n   */\n  setData(data) {\n    try {\n      this.validateData(data);\n      if (!Array.isArray(data)) {\n        throw new Error('Data must be an array of series.');\n      }\n      this.data = data;\n      const allValues = data.flatMap(series => series.data.map(point => point.value));\n      this.minValue = Math.min(...allValues);\n      this.maxValue = Math.max(...allValues);\n      this.calculateNiceRange();\n      this.visibleDataCount = this.calculateVisibleDataCount();\n      this.redrawGraph();\n    } catch (error) {\n      console.error('Error setting data:', error);\n      EventManager.emit('graph:error', {\n        type: 'data',\n        error\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Validates the structure of input data\n   * @param {Object} data - Data to validate\n   * @returns {boolean} True if data structure is valid\n   */\n  validateData(data) {\n    if (!Array.isArray(data)) {\n      throw new Error('Data must be an array of series');\n    }\n\n    data.forEach((series, index) => {\n      if (!series.name || !Array.isArray(series.data)) {\n        throw new Error(`Invalid series at index ${index}`);\n      }\n\n      series.data.forEach((point, pointIndex) => {\n        if (!point.hasOwnProperty('value') || !point.hasOwnProperty('label')) {\n          throw new Error(`Invalid data point in series \"${series.name}\" at index ${pointIndex}`);\n        }\n      });\n    });\n\n    return true;\n  }\n\n  /**\n   * Calculates a \"nice\" range for the y-axis based on the data\n   */\n  calculateNiceRange() {\n    const range = this.maxValue - this.minValue;\n    if (range === 0) {\n      this.minNice = this.minValue - 1;\n      this.maxNice = this.maxValue + 1;\n      return;\n    }\n    const roughStep = range / 5;\n    const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));\n    const niceStep = Math.ceil(roughStep / magnitude) * magnitude;\n\n    this.minNice = Math.floor(this.minValue / niceStep) * niceStep;\n    this.maxNice = Math.ceil(this.maxValue / niceStep) * niceStep;\n\n    if (this.minValue > 0) {\n      if (this.minValue === this.minNice) {\n        this.minNice = Math.max(0, this.minNice - niceStep);\n      }\n      if (this.maxValue === this.maxNice) {\n        this.maxNice += niceStep;\n      }\n    }\n\n    if (this.maxValue < 0) {\n      if (this.maxValue === this.maxNice) {\n        this.maxNice = Math.min(0, this.maxNice + niceStep);\n      }\n      if (this.minValue === this.minNice) {\n        this.minNice -= niceStep;\n      }\n    }\n  }\n\n  /**\n   * Draws the axes on the graph\n   */\n  drawAxes() {\n    const axesGroup = this.createSVGElement('g', {class: 'axes'});\n\n    let yBase = 0;\n    if (this.minNice > 0) {\n      yBase = this.minNice;\n    } else if (this.maxNice < 0) {\n      yBase = this.maxNice;\n    }\n\n    const xAxis = this.createSVGElement('line', {\n      x1: this.margin.left,\n      y1: this.getPointY(yBase),\n      x2: this.width - this.margin.right,\n      y2: this.getPointY(yBase),\n      stroke: this.config.axisColor,\n      'stroke-width': '2'\n    });\n    axesGroup.appendChild(xAxis);\n\n    const yAxis = this.createSVGElement('line', {\n      x1: this.margin.left,\n      y1: this.margin.top,\n      x2: this.margin.left,\n      y2: this.height - this.margin.bottom,\n      stroke: this.config.axisColor,\n      'stroke-width': '2'\n    });\n    axesGroup.appendChild(yAxis);\n\n    if (this.config.showAxisLabels) {\n      this.drawYAxisLabels(axesGroup);\n    }\n\n    this.svg.appendChild(axesGroup);\n  }\n\n  /**\n   * Draws the Y-axis labels\n   * @param {SVGElement} axesGroup - The group element to append the labels to\n   */\n  drawYAxisLabels(axesGroup) {\n    const steps = 5;\n    for (let i = 0; i <= steps; i++) {\n      const value = this.minNice + (i / steps) * (this.maxNice - this.minNice);\n      const y = this.getPointY(value);\n\n      const label = this.createSVGElement('text', {\n        x: this.margin.left - 10,\n        y: y,\n        'text-anchor': 'end',\n        'alignment-baseline': 'middle',\n        'font-size': this.config.labelFontSize,\n        'font-family': this.config.fontFamily,\n        fill: this.config.textColor\n      });\n\n      label.textContent = this.formatValue(value);\n      axesGroup.appendChild(label);\n    }\n  }\n\n  /**\n   * Draws vertical grid lines at the specified x positions\n   * @param {Array<number>} xPositions - The x positions for the grid lines\n   */\n  drawVerticalGridLines(xPositions) {\n    const gridGroup = this.createSVGElement('g', {class: 'vertical-grid'});\n\n    xPositions.forEach(x => {\n      const line = this.createSVGElement('line', {\n        x1: x,\n        y1: this.margin.top,\n        x2: x,\n        y2: this.height - this.margin.bottom,\n        stroke: this.config.gridColor,\n        'stroke-dasharray': '5,5'\n      });\n      gridGroup.appendChild(line);\n    });\n\n    this.svg.appendChild(gridGroup);\n  }\n\n  /**\n   * Draws a horizontal grid line at the specified y position\n   * @param {number} y - The y position for the grid line\n   */\n  drawHorizontalGridLines(y) {\n    const gridLine = this.createSVGElement('line', {\n      x1: this.margin.left,\n      y1: y,\n      x2: this.width - this.margin.right,\n      y2: y,\n      stroke: this.config.gridColor,\n      'stroke-width': '1',\n      'stroke-dasharray': '5,5'\n    });\n    this.svg.appendChild(gridLine);\n  }\n\n  /**\n   * Draws a label at the specified position with optional rotation\n   * @param {number} x - The x position of the label\n   * @param {number} y - The y position of the label\n   * @param {string} text - The text content of the label\n   * @param {boolean} rotate - Whether to rotate the label by 45 degrees\n   */\n  drawLabel(x, y, text, rotate) {\n    const label = this.createSVGElement('text', {\n      x: x,\n      y: y,\n      'text-anchor': 'middle',\n      'font-size': this.config.labelFontSize,\n      'font-family': this.config.fontFamily,\n      fill: this.config.textColor\n    });\n    label.textContent = text;\n    if (rotate) {\n      label.setAttribute('transform', `rotate(45, ${x}, ${y})`);\n    }\n    this.svg.appendChild(label);\n  }\n\n  /**\n   * Adds an animation to an SVG element\n   * @param {SVGElement} element - The SVG element to animate\n   * @param {Object} attributes - The attributes to animate\n   */\n  addAnimation(element, attributes) {\n    if (this.config.animation) {\n      const animate = this.createSVGElement('animate');\n      for (const [key, value] of Object.entries(attributes)) {\n        animate.setAttribute(key, value);\n      }\n      element.appendChild(animate);\n    }\n  }\n\n  /**\n   * Renders the graph based on the current chart type\n   * @param {boolean} [animation=this.config.animation] - Whether to animate the rendering\n   */\n  renderGraph(animation = this.config.animation) {\n    const svg = this.ensureSVG();\n    if (!svg) {\n      // SVG isn't ready yet, the retry is scheduled in ensureSVG()\n      return;\n    }\n\n    try {\n      // Update dimensions based on current container size\n      this.width = this.container.clientWidth;\n      this.height = this.container.clientHeight;\n\n      // Don't render if dimensions are too small\n      if (this.width < 50 || this.height < 50) {\n        setTimeout(() => this.redrawGraph(), 100);\n        return;\n      }\n\n      // Clear existing content\n      while (svg.firstChild) {\n        svg.removeChild(svg.firstChild);\n      }\n\n      const previousAnimation = this.config.animation;\n      this.config.animation = animation;\n      this.clear();\n      this.setMargins();\n      switch (this.currentChartType) {\n        case 'line':\n          this.drawLineGraph();\n          break;\n        case 'bar':\n          this.drawBarGraph();\n          break;\n        case 'pie':\n          this.drawPieChart(false);\n          break;\n        case 'donut':\n          this.drawPieChart(true);\n          break;\n        case 'gauge':\n          this.drawGauge();\n          break;\n        default:\n          throw new Error(`Unknown chart type: ${this.currentChartType}`);\n      }\n      this.drawLegend();\n      this.config.animation = previousAnimation;\n    } catch (error) {\n      console.error('Error in renderGraph():', error);\n    }\n  }\n\n  /**\n   * Redraws the graph without animation\n   * @param {boolean} [animation=this.config.animation] - Whether to animate the redrawing\n   */\n  redrawGraph(animation = this.config.animation) {\n    this.renderGraph(animation);\n  }\n\n  /**\n   * Calculates the x-coordinate for a data point based on its index\n   * @param {number} index - The index of the data point\n   * @returns {number} The x-coordinate\n   */\n  getPointX(index) {\n    if (this.visibleDataCount <= 1) {\n      return this.margin.left + (this.width - this.margin.left - this.margin.right) / 2;\n    }\n    const availableWidth = this.width - this.margin.left - this.margin.right;\n    return this.margin.left + (index / (this.visibleDataCount - 1)) * availableWidth;\n  }\n\n  /**\n   * Calculates the y-coordinate for a data value\n   * @param {number} value - The data value\n   * @returns {number} The y-coordinate\n   */\n  getPointY(value) {\n    const availableHeight = this.height - this.margin.top - this.margin.bottom;\n    if (this.maxNice === this.minNice) {\n      return this.margin.top + availableHeight / 2;\n    }\n    return this.margin.top + ((this.maxNice - value) / (this.maxNice - this.minNice)) * availableHeight;\n  }\n\n  /**\n   * Generates a linear path string for a series of data points\n   * @param {Array<Object>} data - The data points\n   * @returns {string} The path string\n   */\n  getLinearPath(data) {\n    return data.map((point, index) =>\n      `${index === 0 ? 'M' : 'L'}${this.getPointX(index)},${this.getPointY(point.value)}`\n    ).join(' ');\n  }\n\n  /**\n   * Generates a curved path string for a series of data points\n   * @param {Array<Object>} data - The data points\n   * @returns {string} The curved path string\n   */\n  getCurvePath(data) {\n    if (data.length === 0) return '';\n    let path = `M${this.getPointX(0)},${this.getPointY(data[0].value)}`;\n\n    for (let i = 1; i < data.length; i++) {\n      const x1 = this.getPointX(i - 1);\n      const y1 = this.getPointY(data[i - 1].value);\n      const x2 = this.getPointX(i);\n      const y2 = this.getPointY(data[i].value);\n\n      const controlX1 = x1 + (x2 - x1) / 3;\n      const controlX2 = x2 - (x2 - x1) / 3;\n\n      path += ` C${controlX1},${y1} ${controlX2},${y2} ${x2},${y2}`;\n    }\n\n    return path;\n  }\n\n  /**\n   * Describes an arc path\n   * @param {number} x - The x-coordinate of the center\n   * @param {number} y - The y-coordinate of the center\n   * @param {number} radius - The radius of the arc\n   * @param {number} startAngle - The start angle in radians\n   * @param {number} endAngle - The end angle in radians\n   * @returns {string} The SVG path data for the arc\n   */\n  describeArc(x, y, radius, startAngle, endAngle) {\n    const start = this.polarToCartesian(x, y, radius, endAngle);\n    const end = this.polarToCartesian(x, y, radius, startAngle);\n    const largeArcFlag = endAngle - startAngle <= Math.PI ? \"0\" : \"1\";\n    return [\n      \"M\", start.x, start.y,\n      \"A\", radius, radius, 0, largeArcFlag, 0, end.x, end.y\n    ].join(\" \");\n  }\n\n  /**\n   * Converts polar coordinates to Cartesian coordinates\n   * @param {number} centerX - The x-coordinate of the center\n   * @param {number} centerY - The y-coordinate of the center\n   * @param {number} radius - The radius\n   * @param {number} angleInRadians - The angle in radians\n   * @returns {Object} The Cartesian coordinates\n   */\n  polarToCartesian(centerX, centerY, radius, angleInRadians) {\n    return {\n      x: centerX + (radius * Math.cos(angleInRadians)),\n      y: centerY + (radius * Math.sin(angleInRadians))\n    };\n  }\n\n  /**\n   * Adds a single data point to a specific series\n   * @param {Object} newData - The new data point to add\n   * @param {number} [seriesIndex=0] - The index of the series to add the data point to\n   */\n  addDataPoint(newData, seriesIndex = 0) {\n    if (seriesIndex >= this.data.length) {\n      console.error('Series index out of range.');\n      return;\n    }\n\n    this.data[seriesIndex].data.push(newData);\n    if (this.config.maxDataPoints !== 0 && this.data[seriesIndex].data.length > this.config.maxDataPoints) {\n      const removed = this.data[seriesIndex].data.shift();\n      if (removed.value === this.minValue || removed.value === this.maxValue) {\n        const allValues = this.data.flatMap(series => series.data.map(point => point.value));\n        this.minValue = Math.min(...allValues);\n        this.maxValue = Math.max(...allValues);\n      }\n    } else {\n      this.minValue = Math.min(this.minValue, newData.value);\n      this.maxValue = Math.max(this.maxValue, newData.value);\n    }\n\n    this.calculateNiceRange();\n    this.visibleDataCount = this.calculateVisibleDataCount();\n    this.redrawGraph();\n  }\n\n  /**\n   * Draws a line graph based on the current data\n   */\n  drawLineGraph() {\n    const visibleDataCount = this.visibleDataCount;\n    if (visibleDataCount === 0) {\n      return;\n    }\n\n    const seriesCount = this.data.length;\n    const margin = this.margin;\n    const availableWidth = this.width - margin.left - margin.right;\n\n    if (this.config.showGrid) {\n      const steps = 5;\n      for (let i = 0; i <= steps; i++) {\n        const y = this.getPointY(this.minNice + (i / steps) * (this.maxNice - this.minNice));\n        this.drawHorizontalGridLines(y);\n      }\n\n      const xPositionsSet = new Set();\n      for (let i = 0; i < visibleDataCount; i++) {\n        const x = this.getPointX(i);\n        xPositionsSet.add(x);\n      }\n\n      const xPositions = Array.from(xPositionsSet);\n      this.drawVerticalGridLines(xPositions);\n    }\n\n    if (this.config.showAxisLabels && seriesCount > 0) {\n      const labels = this.data[0].data.slice(0, this.visibleDataCount).map(point => this.stripTags(point.label));\n      const labelText = labels.join(' ');\n      const estimatedWidth = this.estimateTextWidth(labelText);\n      const totalLabelWidth = estimatedWidth + (visibleDataCount * 10);\n      const rotate = availableWidth < totalLabelWidth;\n\n      labels.forEach((label, i) => {\n        const x = this.getPointX(i);\n        this.drawLabel(x, this.height - this.margin.bottom + 20, label, rotate);\n      });\n    }\n\n    if (this.config.showAxis) {\n      this.drawAxes();\n    }\n\n    const lineGroup = this.createSVGElement('g', {class: 'lines'});\n\n    const clipPathId = `clipPath-${Date.now()}`;\n    const clipPath = this.createSVGElement('clipPath', {id: clipPathId});\n\n    if (this.config.animation) {\n      const clipRect = this.createSVGElement('rect', {\n        x: margin.left,\n        y: margin.top,\n        width: '0',\n        height: this.height - margin.top - margin.bottom\n      });\n\n      const animateClip = this.createSVGElement('animate', {\n        attributeName: 'width',\n        from: '0',\n        to: availableWidth,\n        dur: `${this.config.animationDuration}ms`,\n        fill: 'freeze'\n      });\n      clipRect.appendChild(animateClip);\n      clipPath.appendChild(clipRect);\n      this.svg.appendChild(clipPath);\n    }\n\n    this.data.forEach((series, seriesIndex) => {\n      const color = series.color || this.config.colors[seriesIndex % this.config.colors.length];\n      const linePath = this.createSVGElement('path', {\n        d: this.config.curve\n          ? this.getCurvePath(series.data.slice(0, this.visibleDataCount))\n          : this.getLinearPath(series.data.slice(0, this.visibleDataCount)),\n        stroke: color,\n        fill: 'none',\n        'stroke-width': this.config.lineWidth\n      });\n\n      if (this.config.fillArea) {\n        const fillPath = this.createSVGElement('path', {fill: color, 'fill-opacity': this.config.fillOpacity, 'clip-path': `url(#${clipPathId})`});\n        const fillY = this.minNice >= 0\n          ? this.getPointY(this.minNice)\n          : this.maxNice <= 0\n            ? this.getPointY(this.maxNice)\n            : this.getPointY(0);\n\n        const finalD = `${linePath.getAttribute('d')} L${this.getPointX(this.visibleDataCount - 1)},${fillY} L${this.getPointX(0)},${fillY} Z`;\n        let initialD = '';\n\n        if (this.config.animation) {\n          linePath.setAttribute('clip-path', `url(#${clipPathId})`);\n          initialD = series.data.slice(0, this.visibleDataCount).map((point, index) =>\n            `${index === 0 ? 'M' : 'L'}${this.getPointX(index)},${fillY}`\n          ).join(' ') + ' Z';\n          fillPath.setAttribute('d', initialD);\n          const animateFill = this.createSVGElement('animate', {\n            attributeName: 'd',\n            from: initialD,\n            to: finalD,\n            dur: `${this.config.animationDuration}ms`,\n            fill: 'freeze'\n          });\n          fillPath.appendChild(animateFill);\n        } else {\n          fillPath.setAttribute('d', finalD);\n        }\n\n        lineGroup.appendChild(fillPath);\n      }\n\n      if (this.config.animation) {\n        const length = linePath.getTotalLength();\n        linePath.setAttribute('stroke-dasharray', length);\n        linePath.setAttribute('stroke-dashoffset', length);\n\n        const animate = this.createSVGElement('animate', {\n          attributeName: 'stroke-dashoffset',\n          from: length,\n          to: '0',\n          dur: `${this.config.animationDuration}ms`,\n          fill: 'freeze'\n        });\n        linePath.appendChild(animate);\n      }\n\n      if (typeof this.config.onClick === 'function') {\n        linePath.style.cursor = 'pointer';\n        linePath.addEventListener('click', () => {\n          this.config.onClick({\n            type: 'line',\n            series: series,\n            data: series.data.slice(0, this.visibleDataCount)\n          });\n        });\n      }\n\n      lineGroup.appendChild(linePath);\n    });\n\n    this.svg.appendChild(lineGroup);\n\n    const pointsGroup = this.createSVGElement('g', {class: 'points'});\n\n    this.data.forEach((series, seriesIndex) => {\n      const color = series.color || this.config.colors[seriesIndex % this.config.colors.length];\n      series.data.slice(0, this.visibleDataCount).forEach((point, index) => {\n        const x = this.getPointX(index);\n        const y = this.getPointY(point.value);\n\n        if (this.config.showDataLabels) {\n          const verticalLineHeight = -15;\n          const horizontalLineLength = 5;\n\n          const verticalLineXEnd = x + horizontalLineLength;\n          const verticalLineYEnd = y + verticalLineHeight;\n\n          const lineVertical = this.createSVGElement('line', {\n            x1: x,\n            y1: y,\n            x2: this.config.animation ? x : verticalLineXEnd,\n            y2: this.config.animation ? y : verticalLineYEnd,\n            stroke: color,\n            'stroke-width': '1'\n          });\n\n          if (this.config.animation) {\n            const animateVerticalLine = this.createSVGElement('animate', {\n              attributeName: 'y2',\n              from: y,\n              to: verticalLineYEnd,\n              dur: '0.5s',\n              fill: 'freeze'\n            });\n            lineVertical.appendChild(animateVerticalLine);\n            const animateHorizontalLine = this.createSVGElement('animate', {\n              attributeName: 'x2',\n              from: x,\n              to: verticalLineXEnd,\n              dur: '0.5s',\n              fill: 'freeze'\n            });\n            lineVertical.appendChild(animateHorizontalLine);\n          }\n\n          pointsGroup.appendChild(lineVertical);\n\n          const horizontalLineXEnd = verticalLineXEnd + horizontalLineLength;\n          const lineHorizontal = this.createSVGElement('line', {\n            x1: verticalLineXEnd,\n            y1: verticalLineYEnd,\n            y2: verticalLineYEnd,\n            stroke: color,\n            'stroke-width': '1'\n          });\n\n          if (this.config.animation) {\n            lineHorizontal.setAttribute('x2', verticalLineXEnd);\n            const animateHorizontalLine = this.createSVGElement('animate', {\n              attributeName: 'x2',\n              from: verticalLineXEnd,\n              to: horizontalLineXEnd,\n              dur: '0.5s',\n              begin: '0.5s',\n              fill: 'freeze'\n            });\n            lineHorizontal.appendChild(animateHorizontalLine);\n          } else {\n            lineHorizontal.setAttribute('x2', horizontalLineXEnd);\n          }\n\n          pointsGroup.appendChild(lineHorizontal);\n\n          const label = this.createSVGElement('text', {\n            x: horizontalLineXEnd,\n            y: verticalLineYEnd,\n            'text-anchor': horizontalLineXEnd > x ? 'start' : 'end',\n            'alignment-baseline': 'middle',\n            'font-size': this.config.labelFontSize,\n            'font-family': this.config.fontFamily,\n            fill: color\n          });\n          label.textContent = this.getLabelContent(series, point);\n\n          if (this.config.animation) {\n            label.setAttribute('opacity', '0');\n\n            const animateOpacity = this.createSVGElement('animate', {\n              attributeName: 'opacity',\n              from: '0',\n              to: '1',\n              dur: '0.5s',\n              begin: '0.5s',\n              fill: 'freeze'\n            });\n            label.appendChild(animateOpacity);\n\n            const animatePosition = this.createSVGElement('animateTransform', {\n              attributeName: 'transform',\n              type: 'translate',\n              from: `0,0`,\n              to: `${horizontalLineLength},0`,\n              dur: '0.5s',\n              begin: '0.5s',\n              fill: 'freeze'\n            });\n            label.appendChild(animatePosition);\n          }\n\n          pointsGroup.appendChild(label);\n        }\n\n        const circle = this.createSVGElement('circle', {\n          cx: x,\n          cy: y,\n          r: this.config.animation ? '0' : this.config.pointRadius,\n          fill: this.config.backgroundColor,\n          stroke: color,\n          'stroke-width': 2\n        });\n\n        if (this.config.showTooltip) {\n          const title = this.createSVGElement('title');\n          title.textContent = this.getTooltipContent(series, point);\n          circle.appendChild(title);\n          circle.setAttribute('cursor', 'pointer');\n        }\n\n        if (typeof this.config.onClick === 'function') {\n          circle.style.cursor = 'pointer';\n          circle.addEventListener('click', () => {\n            this.config.onClick({\n              type: 'point',\n              series: series,\n              data: point\n            });\n          });\n        }\n\n        if (this.config.animation) {\n          const animateRadius = this.createSVGElement('animate', {\n            attributeName: 'r',\n            from: '0',\n            to: this.config.pointRadius,\n            dur: `${this.config.animationDuration}ms`,\n            fill: 'freeze'\n          });\n          circle.appendChild(animateRadius);\n\n          const animateOpacity = this.createSVGElement('animate', {\n            attributeName: 'opacity',\n            from: '0',\n            to: '1',\n            dur: `${this.config.animationDuration}ms`,\n            fill: 'freeze'\n          });\n          circle.appendChild(animateOpacity);\n        }\n\n        pointsGroup.appendChild(circle);\n      });\n    });\n\n    this.svg.appendChild(pointsGroup);\n\n    if (this.config.showCenterText) {\n      const centerText = this.createSVGElement('text', {\n        x: this.width / 2,\n        y: this.height / 2,\n        'text-anchor': 'middle',\n        'font-size': this.config.fontSize,\n        'font-family': this.config.fontFamily,\n        fill: this.config.textColor,\n        'font-weight': 'bold'\n      });\n      centerText.textContent = this.config.centerText || '';\n      this.svg.appendChild(centerText);\n    }\n  }\n\n  /**\n   * Draws a bar graph based on the current data with shadow effects on top and sides\n   */\n  drawBarGraph() {\n    const visibleDataCount = this.visibleDataCount;\n    if (visibleDataCount === 0) {\n      return;\n    }\n\n    const seriesCount = this.data.length;\n    const margin = this.margin;\n    const availableWidth = this.width - margin.left - margin.right;\n    const groupWidth = availableWidth / visibleDataCount;\n    const barWidth = groupWidth / (seriesCount + 1);\n    const barGap = (groupWidth - seriesCount * barWidth) / (seriesCount + 1);\n    const zeroY = this.getPointY(0);\n\n    const defs = this.createSVGElement('defs');\n    const filter = this.createSVGElement('filter', {\n      id: 'barShadow',\n      x: '-20%',\n      y: '-20%',\n      width: '140%',\n      height: '140%'\n    });\n    const feOffset = this.createSVGElement('feOffset', {\n      dx: '2',\n      dy: '-2',\n      result: 'offsetBlur'\n    });\n    const feGaussianBlur = this.createSVGElement('feGaussianBlur', {\n      in: 'offsetBlur',\n      stdDeviation: '2',\n      result: 'blur'\n    });\n    const feFlood = this.createSVGElement('feFlood', {\n      'flood-color': '#000000',\n      'flood-opacity': '0.3',\n      result: 'color'\n    });\n    const feComposite = this.createSVGElement('feComposite', {\n      in: 'color',\n      in2: 'blur',\n      operator: 'in',\n      result: 'shadow'\n    });\n    const feMerge = this.createSVGElement('feMerge');\n    const feMergeNode1 = this.createSVGElement('feMergeNode', {in: 'shadow'});\n    const feMergeNode2 = this.createSVGElement('feMergeNode', {in: 'SourceGraphic'});\n\n    filter.appendChild(feOffset);\n    filter.appendChild(feGaussianBlur);\n    filter.appendChild(feFlood);\n    filter.appendChild(feComposite);\n    filter.appendChild(feMerge);\n    feMerge.appendChild(feMergeNode1);\n    feMerge.appendChild(feMergeNode2);\n    defs.appendChild(filter);\n    this.svg.appendChild(defs);\n\n    if (this.config.showGrid) {\n      const steps = 5;\n      for (let i = 0; i <= steps; i++) {\n        const y = this.getPointY(this.minNice + (i / steps) * (this.maxNice - this.minNice));\n        this.drawHorizontalGridLines(y);\n      }\n    }\n\n    const xPositions = [];\n    for (let i = 0; i < visibleDataCount; i++) {\n      const x = margin.left + i * groupWidth;\n      xPositions.push(x);\n    }\n\n    if (this.config.showGrid) {\n      this.drawVerticalGridLines(xPositions.map(x => x + groupWidth));\n    }\n\n    if (this.config.showAxisLabels && this.data.length > 0) {\n      const labels = this.data[0].data.slice(0, this.visibleDataCount).map(point => this.stripTags(point.label));\n      const labelText = labels.join(' ');\n      const estimatedWidth = this.estimateTextWidth(labelText);\n      const totalLabelWidth = estimatedWidth + (visibleDataCount * 10);\n      const rotate = availableWidth < totalLabelWidth;\n\n      labels.forEach((label, i) => {\n        const x = xPositions[i] + groupWidth / 2;\n        this.drawLabel(x, this.height - margin.bottom + 20, label, rotate);\n      });\n    }\n\n    this.data.forEach((series, seriesIndex) => {\n      series.data.slice(0, visibleDataCount).forEach((point, index) => {\n        const x = xPositions[index] + barGap + seriesIndex * (barWidth + barGap);\n        let y, height;\n        const yValue = this.getPointY(point.value);\n        if (this.minNice >= 0 && this.maxNice >= 0) {\n          y = yValue;\n          height = this.getPointY(this.minNice) - yValue;\n        } else if (this.minNice <= 0 && this.maxNice <= 0) {\n          y = this.getPointY(this.maxNice);\n          height = yValue - y;\n        } else {\n          y = Math.min(zeroY, yValue);\n          height = Math.abs(zeroY - yValue);\n        }\n\n        const color = point.color || series.color || this.config.colors[seriesIndex % this.config.colors.length];\n\n        const bar = this.createSVGElement('rect', {\n          x: x,\n          width: barWidth,\n          height: this.config.animation ? '0' : height,\n          fill: color,\n          filter: 'url(#barShadow)'\n        });\n\n        if (this.config.borderColor) {\n          bar.setAttribute('stroke', this.config.borderColor === 'auto' ? this.darkenColor(color) : this.config.borderColor);\n          bar.setAttribute('stroke-width', this.config.borderWidth);\n        }\n\n        if (this.config.showTooltip) {\n          const title = this.createSVGElement('title');\n          title.textContent = this.getTooltipContent(series, point);\n          bar.appendChild(title);\n          bar.setAttribute('cursor', 'pointer');\n        }\n\n        if (typeof this.config.onClick === 'function') {\n          bar.style.cursor = 'pointer';\n          bar.addEventListener('click', () => {\n            this.config.onClick({\n              type: 'bar',\n              series: series,\n              data: point\n            });\n          });\n        }\n\n        let yForm;\n        if (this.minNice >= 0 && this.maxNice >= 0) {\n          yForm = this.getPointY(this.minNice);\n        } else if (this.minNice < 0 && this.maxNice < 0) {\n          yForm = this.getPointY(this.maxNice);\n        } else {\n          yForm = this.getPointY(0);\n        }\n\n        if (this.config.animation) {\n          bar.setAttribute('y', y);\n          const animHeight = this.createSVGElement('animate', {\n            attributeName: 'height',\n            from: '0',\n            to: height,\n            dur: `${this.config.animationDuration}ms`,\n            fill: 'freeze'\n          });\n          bar.appendChild(animHeight);\n\n          const animY = this.createSVGElement('animate', {\n            attributeName: 'y',\n            from: yForm,\n            to: y,\n            dur: `${this.config.animationDuration}ms`,\n            fill: 'freeze'\n          });\n          bar.appendChild(animY);\n        } else {\n          bar.setAttribute('y', y);\n          bar.setAttribute('height', height);\n        }\n\n        this.svg.appendChild(bar);\n\n        if (this.config.showDataLabels) {\n          const label = this.createSVGElement('text', {\n            x: x + barWidth / 2,\n            'text-anchor': 'middle',\n            'font-size': this.config.labelFontSize,\n            'font-family': this.config.fontFamily,\n            fill: color\n          });\n          label.textContent = this.getLabelContent(series, point);\n\n          if (point.value >= 0) {\n            label.setAttribute('y', y - 5);\n            if (this.config.animation) {\n              const animLabelY = this.createSVGElement('animate', {\n                attributeName: 'y',\n                from: yForm - 5,\n                to: y - 5,\n                dur: `${this.config.animationDuration}ms`,\n                fill: 'freeze'\n              });\n              label.appendChild(animLabelY);\n            }\n          } else {\n            label.setAttribute('y', y + height + 15);\n            if (this.config.animation) {\n              const animLabelY = this.createSVGElement('animate', {\n                attributeName: 'y',\n                from: yForm + 15,\n                to: y + height + 15,\n                dur: `${this.config.animationDuration}ms`,\n                fill: 'freeze'\n              });\n              label.appendChild(animLabelY);\n            }\n          }\n\n          this.svg.appendChild(label);\n        }\n      });\n    });\n\n    if (this.config.showAxis) {\n      this.drawAxes();\n    }\n  }\n\n  /**\n   * Draws a pie or donut chart based on the current data\n   * @param {boolean} isDonut - Whether to draw a donut chart instead of a pie chart\n   */\n  drawPieChart(isDonut = false) {\n    if (!this.data || !this.data.length) return;\n\n    const radius = Math.min(\n      this.width - this.margin.left - this.margin.right,\n      this.height - this.margin.top - this.margin.bottom\n    ) / 2.0;\n    const centerX = this.margin.left + (this.width - this.margin.left - this.margin.right) / 2;\n    const centerY = this.margin.top + (this.height - this.margin.top - this.margin.bottom) / 2;\n\n    let startAngle = -Math.PI / 2;\n\n    const total = this.data.reduce((sum, series) => sum + series.data.reduce((s, p) => s + p.value, 0), 0);\n    if (total === 0) {\n      console.warn('Total value of pie chart is 0. Cannot draw pie chart.');\n      return;\n    }\n    const pieGroup = this.createSVGElement('g', {class: 'pie-group'});\n\n    this.data.forEach((series, seriesIndex) => {\n      series.data.forEach((point, index) => {\n        const sliceAngle = (point.value / total) * 2 * Math.PI;\n        const endAngle = startAngle + sliceAngle;\n        const midAngle = startAngle + sliceAngle / 2;\n        const color = point.color || series.color || this.config.colors[index % this.config.colors.length];\n\n        const x1 = centerX + radius * Math.cos(startAngle);\n        const y1 = centerY + radius * Math.sin(startAngle);\n        const x2 = centerX + radius * Math.cos(endAngle);\n        const y2 = centerY + radius * Math.sin(endAngle);\n\n        const largeArcFlag = sliceAngle > Math.PI ? \"1\" : \"0\";\n\n        const pathData = [\n          `M ${centerX} ${centerY}`,\n          `L ${x1} ${y1}`,\n          `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`,\n          'Z'\n        ].join(' ');\n\n        const borderColor = this.config.borderColor === 'auto' ? this.darkenColor(color) : this.config.borderColor;\n\n        const slice = this.createSVGElement('path', {\n          d: pathData,\n          fill: color,\n          stroke: this.config.gap > 0 ? this.config.backgroundColor : (this.config.borderWidth > 0 ? (borderColor || '#000') : null),\n          'stroke-width': this.config.gap > 0 || this.config.borderWidth > 0 ? this.config.gap > 0 ? this.config.gap : this.config.borderWidth : null\n        });\n\n        if (this.config.showTooltip) {\n          const title = this.createSVGElement('title');\n          title.textContent = this.getTooltipContent(series, point);\n          slice.appendChild(title);\n          slice.setAttribute('cursor', 'pointer');\n        }\n\n        if (typeof this.config.onClick === 'function') {\n          slice.style.cursor = 'pointer';\n          slice.addEventListener('click', () => {\n            this.config.onClick({\n              type: 'pie',\n              series: series,\n              data: point\n            });\n          });\n        }\n\n        if (this.config.animation) {\n          const pathLength = slice.getTotalLength();\n          slice.setAttribute('stroke-dasharray', pathLength);\n          slice.setAttribute('stroke-dashoffset', pathLength);\n\n          const animateSlice = this.createSVGElement('animate', {\n            attributeName: 'stroke-dashoffset',\n            from: pathLength,\n            to: '0',\n            dur: `${this.config.animationDuration}ms`,\n            fill: 'freeze'\n          });\n          slice.appendChild(animateSlice);\n        }\n\n        pieGroup.appendChild(slice);\n\n        if (this.config.showDataLabels) {\n          const labelRadius = radius * 1.2;\n          const labelX = centerX + labelRadius * Math.cos(midAngle);\n          const labelY = centerY + labelRadius * Math.sin(midAngle);\n\n          const x = centerX + radius * Math.cos(midAngle);\n          const y = centerY + radius * Math.sin(midAngle);\n\n          const lineVertical = this.createSVGElement('line', {\n            x1: x,\n            y1: y,\n            x2: this.config.animation ? x : labelX,\n            y2: this.config.animation ? y : labelY,\n            stroke: color,\n            'stroke-width': '1'\n          });\n\n          if (this.config.animation) {\n            const animateVerticalLineX = this.createSVGElement('animate', {\n              attributeName: 'x2',\n              from: x,\n              to: labelX,\n              dur: '0.5s',\n              fill: 'freeze'\n            });\n            lineVertical.appendChild(animateVerticalLineX);\n\n            const animateVerticalLine = this.createSVGElement('animate', {\n              attributeName: 'y2',\n              from: y,\n              to: labelY,\n              dur: '0.5s',\n              fill: 'freeze'\n            });\n            lineVertical.appendChild(animateVerticalLine);\n          }\n          pieGroup.appendChild(lineVertical);\n\n          const horizontalLineLength = 5;\n          const horizontalLineXEnd = labelX > centerX ? labelX + horizontalLineLength : labelX - horizontalLineLength;\n\n          const lineHorizontal = this.createSVGElement('line', {\n            x1: labelX,\n            y1: labelY,\n            y2: labelY,\n            stroke: color,\n            'stroke-width': '1'\n          });\n\n          if (this.config.animation) {\n            lineHorizontal.setAttribute('x2', labelX);\n            const animateHorizontalLine = this.createSVGElement('animate', {\n              attributeName: 'x2',\n              from: labelX,\n              to: horizontalLineXEnd,\n              dur: '0.5s',\n              begin: `${this.config.animationDuration / 2}ms`,\n              fill: 'freeze'\n            });\n            lineHorizontal.appendChild(animateHorizontalLine);\n          } else {\n            lineHorizontal.setAttribute('x2', horizontalLineXEnd);\n          }\n          pieGroup.appendChild(lineHorizontal);\n\n          const label = this.createSVGElement('text', {\n            x: horizontalLineXEnd + (labelX > centerX ? 5 : -5),\n            y: labelY,\n            'text-anchor': labelX > centerX ? 'start' : 'end',\n            'alignment-baseline': 'middle',\n            'font-size': this.config.labelFontSize,\n            fill: color\n          });\n          label.textContent = this.getLabelContent(series, point);\n\n          if (this.config.animation) {\n            label.setAttribute('opacity', '0');\n\n            const animateOpacity = this.createSVGElement('animate', {\n              attributeName: 'opacity',\n              from: '0',\n              to: '1',\n              dur: '0.5s',\n              begin: `${this.config.animationDuration / 2}ms`,\n              fill: 'freeze'\n            });\n            label.appendChild(animateOpacity);\n\n            const animatePosition = this.createSVGElement('animateTransform', {\n              attributeName: 'transform',\n              type: 'translate',\n              to: `0,0`,\n              from: labelX > centerX ? `-${horizontalLineLength + 5},0` : `${horizontalLineLength + 5},0`,\n              dur: '0.5s',\n              begin: `${this.config.animationDuration / 2}ms`,\n              fill: 'freeze'\n            });\n            label.appendChild(animatePosition);\n          }\n\n          pieGroup.appendChild(label);\n        }\n\n        startAngle = endAngle;\n      });\n    });\n\n    if (isDonut) {\n      const donutHole = this.createSVGElement('circle', {\n        cx: centerX,\n        cy: centerY,\n        r: Math.max(0, radius - this.config.donutThickness),\n        fill: this.config.backgroundColor\n      });\n\n      if (this.config.gap <= 0 && this.config.borderWidth > 0) {\n        const borderColor = this.config.borderColor === 'auto' ? this.darkenColor(this.config.colors[0]) : this.config.borderColor;\n        donutHole.setAttribute('stroke', borderColor || '#000');\n        donutHole.setAttribute('stroke-width', this.config.borderWidth);\n      }\n\n      pieGroup.appendChild(donutHole);\n    }\n\n    if (this.config.showCenterText) {\n      const centerText = this.createSVGElement('text', {\n        x: centerX,\n        y: centerY,\n        'text-anchor': 'middle',\n        'alignment-baseline': 'middle',\n        'font-size': this.config.fontSize,\n        fill: this.config.textColor,\n        'font-weight': 'bold'\n      });\n      centerText.textContent = this.config.centerText !== null\n        ? this.config.centerText\n        : isDonut ? `Total: ${total}` : '';\n      this.svg.appendChild(centerText);\n    }\n\n    this.svg.appendChild(pieGroup);\n  }\n\n  /**\n   * Draws a gauge chart based on the current data\n   */\n  drawGauge() {\n    const centerX = this.margin.left + (this.width - this.margin.left - this.margin.right) / 2;\n    const centerY = this.margin.top + (this.height - this.margin.top - this.margin.bottom) / 2;\n\n    const radius = Math.min(\n      this.width - this.margin.left - this.margin.right,\n      this.height - this.margin.top - this.margin.bottom\n    ) / 2.0;\n    const startAngle = -Math.PI * 0.75;\n    const endAngle = Math.PI * 0.75;\n\n    const background = this.createSVGElement('path', {\n      d: this.describeArc(centerX, centerY, radius, startAngle, endAngle),\n      fill: 'none',\n      stroke: this.config.gridColor,\n      'stroke-width': this.config.gaugeCurveWidth\n    });\n    this.svg.appendChild(background);\n\n    const value = this.data[0].data[0].value;\n    const maxValue = this.config.maxGaugeValue || 100;\n    const percentage = (value / maxValue) * 100;\n    const valueAngle = startAngle + (percentage / 100) * (endAngle - startAngle);\n\n    const valuePath = this.createSVGElement('path', {\n      d: this.describeArc(centerX, centerY, radius, startAngle, valueAngle),\n      fill: 'none',\n      stroke: this.data[0].color || this.config.colors[0],\n      'stroke-width': this.config.gaugeCurveWidth,\n      'stroke-linecap': 'round'\n    });\n\n    if (typeof this.config.onClick === 'function') {\n      valuePath.style.cursor = 'pointer';\n      valuePath.addEventListener('click', () => {\n        this.config.onClick({\n          type: 'gauge',\n          series: this.data[0],\n          data: this.data[0].data[0]\n        });\n      });\n    }\n\n    if (this.config.animation) {\n      const length = valuePath.getTotalLength();\n      valuePath.setAttribute('stroke-dasharray', length);\n      valuePath.setAttribute('stroke-dashoffset', length);\n\n      const animateGauge = this.createSVGElement('animate', {\n        attributeName: 'stroke-dashoffset',\n        from: length,\n        to: '0',\n        dur: `${this.config.animationDuration}ms`,\n        fill: 'freeze'\n      });\n      valuePath.appendChild(animateGauge);\n    }\n\n    this.svg.appendChild(valuePath);\n\n    if (this.config.showCenterText) {\n      const centerText = this.createSVGElement('text', {\n        x: centerX,\n        y: centerY,\n        'text-anchor': 'middle',\n        'dominant-baseline': 'middle',\n        'font-size': this.config.fontSize,\n        'font-family': this.config.fontFamily,\n        fill: this.config.textColor,\n        'font-weight': 'bold'\n      });\n      centerText.textContent = this.config.centerText !== null\n        ? this.config.centerText\n        : `${this.formatValue(percentage)}%`;\n      this.svg.appendChild(centerText);\n\n      const label = this.createSVGElement('text', {\n        x: centerX,\n        y: centerY + 30,\n        'text-anchor': 'middle',\n        'font-size': this.config.fontSize * 0.8,\n        'font-family': this.config.fontFamily,\n        fill: this.config.textColor\n      });\n      label.textContent = this.data[0].data[0].label || '';\n      this.svg.appendChild(label);\n    }\n  }\n\n  /**\n   * Draws the legend for the graph using SVG with circular color indicators.\n   */\n  drawLegend() {\n    if (!this.config.showLegend) return;\n\n    if (this.legend) {\n      this.container.parentElement.removeChild(this.legend);\n    }\n\n    this.legend = document.createElement('div');\n    this.legend.className = 'ggraphs-legend';\n    this.legend.style.display = 'flex';\n    this.legend.style.justifyContent = 'center';\n    this.legend.style.flexWrap = 'wrap';\n    this.legend.style.columnGap = '20px';\n\n    if (this.currentChartType === 'pie' || this.currentChartType === 'donut') {\n      this.data.forEach((series) => {\n        series.data.forEach((point, index) => {\n          const color = point.color || series.color || this.config.colors[index % this.config.colors.length];\n          const item = this.createLegendItem(color, point.label);\n          this.legend.appendChild(item);\n        });\n      });\n    } else {\n      this.data.forEach((series, index) => {\n        const color = series.color || this.config.colors[index % this.config.colors.length];\n        const item = this.createLegendItem(color, series.name || `Series ${index + 1}`);\n        this.legend.appendChild(item);\n      });\n    }\n\n    if (this.config.legendPosition === 'top') {\n      this.container.parentElement.insertBefore(this.legend, this.container);\n    } else {\n      this.container.parentElement.appendChild(this.legend);\n    }\n  }\n\n  /**\n   * Creates a single legend item with a colored circle and text.\n   * @param {string} color - The color for the circle.\n   * @param {string} text - The text to display.\n   * @returns {HTMLElement} The legend item element.\n   */\n  createLegendItem(color, text) {\n    const item = document.createElement('div');\n    item.style.display = '-webkit-box';\n    item.style.webkitBoxOrient = 'vertical';\n    item.style.webkitLineClamp = 1;\n    item.style.overflow = 'hidden';\n\n    const colorBox = document.createElement('span');\n    colorBox.style.backgroundColor = color;\n    colorBox.style.width = '1em';\n    colorBox.style.height = '1em';\n    colorBox.style.backgroundColor = color;\n    colorBox.style.borderRadius = '9999px';\n    colorBox.style.display = 'inline-block';\n    colorBox.style.marginRight = '5px';\n\n    const label = document.createElement('span');\n    label.innerHTML = text;\n\n    item.appendChild(colorBox);\n    item.appendChild(label);\n    return item;\n  }\n\n  /**\n   * Retrieves the tooltip content for a data point.\n   * @param {Object} series - The data series.\n   * @param {Object} point - The data point.\n   * @returns {string} The tooltip content.\n   */\n  getTooltipContent(series, point) {\n    if (this.config.tooltipFormatter) {\n      return this.config.tooltipFormatter(series, point);\n    }\n    return `${series.name}: ${this.stripTags(point.label)} - ${this.formatValue(point.value)}`;\n  }\n\n  /**\n   * Retrieves the label content for a data point, using a custom formatter if provided, with length limitation.\n   * @param {Object} series - The data series.\n   * @param {Object} point - The data point.\n   * @returns {string} The label content, truncated if necessary.\n   */\n  getLabelContent(series, point) {\n    if (this.currentChartType === 'pie' || this.currentChartType === 'donut') {\n      return this.config.showValueInsteadOfPercent ?\n        this.formatValue(point.value) :\n        `${this.formatValue((point.value / this.getTotal(series)) * 100)}%`;\n    } else {\n      return this.formatValue(point.value);\n    }\n  }\n\n  /**\n   * Removes HTML tags from a string, returning plain text.\n   * @param {string} html - The string containing HTML tags.\n   * @returns {string} The plain text without HTML tags.\n   */\n  stripTags(html) {\n    const div = document.createElement('div');\n    div.innerHTML = html;\n    return div.textContent || div.innerText || '';\n  }\n\n  /**\n   * Formats a numeric value with commas as thousand separators.\n   * @param {number} value - The value to format.\n   * @returns {string} The formatted value with commas.\n   */\n  formatValue(value) {\n    if (typeof value !== 'number' || isNaN(value)) return value;\n\n    value = Number(value.toFixed(1));\n    const parts = value.toString().split('.');\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n    return parts.join('.');\n  }\n\n  /**\n   * Estimates the width of a given text string.\n   * @param {string} text - The text to measure.\n   * @returns {number} The estimated width in pixels.\n   */\n  estimateTextWidth(text) {\n    const tempText = this.createSVGElement('text', {\n      'font-size': this.config.labelFontSize,\n      'font-family': this.config.fontFamily\n    });\n    tempText.textContent = text;\n    this.svg.appendChild(tempText);\n    const bbox = tempText.getBBox();\n    this.svg.removeChild(tempText);\n    return bbox.width;\n  }\n\n  /**\n   * Retrieves the total value of a series.\n   * @param {Object} series - The data series.\n   * @returns {number} The total value.\n   */\n  getTotal(series) {\n    return series.data.reduce((sum, point) => sum + point.value, 0);\n  }\n\n  /**\n   * Sets the margins of the graph based on the presence of the legend and other options.\n   */\n  setMargins() {\n    let margin = {top: 50, right: 50, bottom: 50, left: 50};\n\n    if (this.config.type === 'gauge') {\n      margin = {top: 66, right: 66, bottom: 66, left: 66};\n    } else if (!this.config.showDataLabels) {\n      if (['pie', 'donut'].includes(this.config.type)) {\n        margin = {top: 30, right: 30, bottom: 30, left: 30};\n      } else if (!this.config.showAxisLabels) {\n        margin = {top: 10, right: 10, bottom: 10, left: 10};\n      }\n    }\n\n    this.margin = margin;\n  }\n\n  /**\n   * Darkens a HEX color by a specified factor.\n   * @param {string} hex - The HEX color code (e.g., '#FF6B6B').\n   * @param {number} factor - The darkening factor (0 to 1, default 0.2).\n   * @returns {string} The darkened HEX color code.\n   */\n  darkenColor(hex, factor = 0.2) {\n    let color = hex.startsWith('#') ? hex.slice(1) : hex;\n    if (color.length === 3) {\n      color = color.split('').map(c => c + c).join('');\n    }\n    const r = Math.max(0, Math.min(255, Math.round(parseInt(color.slice(0, 2), 16) * (1 - factor))));\n    const g = Math.max(0, Math.min(255, Math.round(parseInt(color.slice(2, 4), 16) * (1 - factor))));\n    const b = Math.max(0, Math.min(255, Math.round(parseInt(color.slice(4, 6), 16) * (1 - factor))));\n    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n  }\n\n  /**\n   * Loads and processes data from an HTML table.\n   * @param {HTMLTableElement} table - The table element to load data from.\n   * @returns {Array} The processed series data.\n   */\n  loadAndProcessTableData(table) {\n    const tableData = this.loadFromTable(table);\n    return this.processTableData(tableData);\n  }\n\n  /**\n   * Calculates a nice range for the y-axis and updates the internal state.\n   */\n  calculateNiceRange() {\n    const range = this.maxValue - this.minValue;\n    if (range === 0) {\n      this.minNice = this.minValue - 1;\n      this.maxNice = this.maxValue + 1;\n      return;\n    }\n    const roughStep = range / 5;\n    const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));\n    const niceStep = Math.ceil(roughStep / magnitude) * magnitude;\n\n    this.minNice = Math.floor(this.minValue / niceStep) * niceStep;\n    this.maxNice = Math.ceil(this.maxValue / niceStep) * niceStep;\n\n    if (this.minValue > 0) {\n      if (this.minValue === this.minNice) {\n        this.minNice = Math.max(0, this.minNice - niceStep);\n      }\n      if (this.maxValue === this.maxNice) {\n        this.maxNice += niceStep;\n      }\n    }\n\n    if (this.maxValue < 0) {\n      if (this.maxValue === this.maxNice) {\n        this.maxNice = Math.min(0, this.maxNice + niceStep);\n      }\n      if (this.minValue === this.minNice) {\n        this.minNice -= niceStep;\n      }\n    }\n  }\n\n  /**\n   * Loads data from a table and renders the graph.\n   */\n  initialize() {\n    this.clear();\n    this.calculateFontSize();\n    this.setMargins();\n\n    if (this.config.table) {\n      const table = document.getElementById(this.config.table);\n      if (table) {\n        const processedData = this.loadAndProcessTableData(table);\n        this.setData(processedData);\n      } else {\n        console.warn(`Table with ID \"${this.config.table}\" not found.`);\n      }\n    } else if (this.config.data) {\n      this.setData(this.config.data);\n    }\n\n    this.renderGraph();\n  }\n\n  /**\n   * Destroys the graph instance, removing event listeners and observers.\n   */\n  destroy() {\n    window.removeEventListener('resize', this.handleResize);\n    if (this.container && this.svg && this.container.contains(this.svg)) {\n      this.container.removeChild(this.svg);\n    }\n  }\n\n  /**\n   * Throttle helper\n   * @param {Function} func - The function to throttle.\n   * @param {number} limit - The throttle limit in milliseconds.\n   * @returns {Function} The throttled function.\n   */\n  throttle(func, limit) {\n    let inThrottle;\n    return function(...args) {\n      if (!inThrottle) {\n        func.apply(this, args);\n        inThrottle = true;\n        setTimeout(() => inThrottle = false, limit);\n      }\n    }\n  }\n\n  /**\n   * Add animation system\n   * @param {SVGElement} element - The SVG element to animate.\n   * @param {Object} properties - The properties to animate.\n   * @param {number} duration - The duration of the animation in milliseconds.\n   * @returns {Promise} A promise that resolves when the animation finishes.\n   */\n  animate(element, properties, duration = 1000) {\n    if (!this.config.animation) return;\n\n    const animations = [];\n\n    Object.entries(properties).forEach(([prop, value]) => {\n      const animation = element.animate([\n        {[prop]: element.getAttribute(prop)},\n        {[prop]: value}\n      ], {\n        duration,\n        easing: 'ease-in-out',\n        fill: 'forwards'\n      });\n\n      animations.push(animation);\n    });\n\n    return Promise.all(animations.map(a => a.finished));\n  }\n\n  /**\n   * Helper function to get path length\n   * @param {string} pathData - The path data.\n   * @returns {number} The length of the path.\n   */\n  getPathLength(pathData) {\n    const tempPath = this.createSVGElement('path', {\n      d: pathData\n    });\n    const length = tempPath.getTotalLength();\n    tempPath.remove();\n    return length;\n  }\n\n  /**\n   * Handles touch start events.\n   * @param {TouchEvent} event - The touch event.\n   */\n  handleTouchStart(event) {\n    this.touchStartX = event.touches[0].clientX;\n    this.touchStartY = event.touches[0].clientY;\n  }\n\n  /**\n   * Handles touch move events.\n   * @param {TouchEvent} event - The touch event.\n   */\n  handleTouchMove(event) {\n    if (!this.touchStartX || !this.touchStartY) return;\n\n    const xDiff = this.touchStartX - event.touches[0].clientX;\n    const yDiff = this.touchStartY - event.touches[0].clientY;\n\n    if (Math.abs(xDiff) > Math.abs(yDiff)) {\n      this.pan(xDiff);\n    } else {\n      this.zoom(yDiff);\n    }\n  }\n\n  /**\n   * Handles touch end events.\n   */\n  handleTouchEnd() {\n    this.touchStartX = 0;\n    this.touchStartY = 0;\n  }\n\n  /**\n   * Exports the current graph as an image file (PNG, JPEG, or SVG).\n   * @param {string} [filename='graph'] - The base name of the exported file.\n   * @param {string} [format='png'] - The image format ('png', 'jpeg', or 'svg').\n   * @param {number} [width=this.width] - The width of the exported image (for PNG/JPEG).\n   * @param {number} [height=null] - The height of the exported image (for PNG/JPEG).\n   * @param {number} [quality=0.8] - The quality for JPEG format (0 to 1, for JPEG only).\n   * @param {number} [scale=1] - The scale factor for the exported image (for PNG/JPEG).\n   */\n  exportToImage(filename = 'graph', format = 'png', width = this.width, height = null, quality = 0.8, scale = 1) {\n    const validFormats = ['png', 'jpeg', 'svg'];\n    if (!validFormats.includes(format)) {\n      console.warn(`Invalid format \"${format}\". Defaulting to \"png\".`);\n      format = 'png';\n    }\n\n    if (!this.svg) {\n      console.error('No SVG content to export.');\n      return;\n    }\n\n    const originalAnimations = this.disableAnimations();\n\n    const aspectRatio = this.height / this.width;\n    const exportWidth = format === 'svg' ? this.width : width * scale;\n    const exportHeight = format === 'svg' ? this.height : (height !== null ? height : width * aspectRatio) * scale;\n\n    const svgClone = this.svg.cloneNode(true);\n    svgClone.setAttribute('width', exportWidth);\n    svgClone.setAttribute('height', exportHeight);\n    svgClone.setAttribute('viewBox', `0 0 ${this.width} ${this.height}`);\n    svgClone.insertAdjacentHTML('afterbegin', `<desc>${this.getAccessibilityDescription()}</desc>`);\n\n    const svgString = new XMLSerializer().serializeToString(svgClone);\n\n    this.restoreAnimations(originalAnimations);\n\n    if (format === 'svg') {\n      try {\n        const svgBlob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});\n        const url = URL.createObjectURL(svgBlob);\n        const link = document.createElement('a');\n        link.download = `${filename}.svg`;\n        link.href = url;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        URL.revokeObjectURL(url);\n      } catch (error) {\n        console.error('SVG export failed:', error);\n        throw error;\n      }\n      return;\n    }\n\n    const svgDataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);\n\n    const canvas = document.createElement('canvas');\n    canvas.width = exportWidth;\n    canvas.height = exportHeight;\n\n    try {\n      const ctx = canvas.getContext('2d');\n      if (!ctx) throw new Error('Failed to get canvas context');\n\n      const img = new Image();\n      img.onload = () => {\n        ctx.fillStyle = this.config.backgroundColor;\n        ctx.fillRect(0, 0, exportWidth, exportHeight);\n        ctx.drawImage(img, 0, 0, exportWidth, exportHeight);\n\n        const mimeType = format === 'jpeg' ? 'image/jpeg' : 'image/png';\n        const imageDataUrl = format === 'jpeg' ? canvas.toDataURL(mimeType, quality) : canvas.toDataURL(mimeType);\n\n        const link = document.createElement('a');\n        link.download = `${filename}.${format}`;\n        link.href = imageDataUrl;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n      };\n      img.onerror = () => {\n        console.error('Failed to load SVG for export.');\n      };\n      img.src = svgDataUrl;\n    } catch (error) {\n      console.error('Export failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Disables animations in the SVG temporarily and returns their original states.\n   * @returns {Array} Array of animation elements with their original attributes.\n   */\n  disableAnimations() {\n    const animations = [];\n    const animateElements = this.svg.getElementsByTagName('animate');\n    for (let i = animateElements.length - 1; i >= 0; i--) {\n      const animate = animateElements[i];\n      const parent = animate.parentElement;\n      const attributeName = animate.getAttribute('attributeName');\n      const toValue = animate.getAttribute('to');\n\n      animations.push({element: animate.cloneNode(true), parent});\n      if (attributeName && toValue && parent) {\n        parent.setAttribute(attributeName, toValue);\n        parent.removeChild(animate);\n      }\n    }\n\n    const animateTransforms = this.svg.getElementsByTagName('animateTransform');\n    for (let i = animateTransforms.length - 1; i >= 0; i--) {\n      const animate = animateTransforms[i];\n      const parent = animate.parentElement;\n      const toValue = animate.getAttribute('to');\n\n      animations.push({element: animate.cloneNode(true), parent});\n      if (animate.getAttribute('type') === 'translate' && toValue && parent) {\n        const [x, y] = toValue.split(',');\n        parent.setAttribute('transform', `translate(${x}, ${y})`);\n        parent.removeChild(animate);\n      }\n    }\n\n    return animations;\n  }\n\n  /**\n   * Restores animations to the SVG from their original states.\n   * @param {Array} animations - Array of animation elements with their parents.\n   */\n  restoreAnimations(animations) {\n    animations.forEach(({element, parent}) => {\n      parent.appendChild(element);\n    });\n  }\n\n  /**\n   * Exports the graph to a CSV file.\n   * @returns {string} The CSV data.\n   */\n  exportToCSV() {\n    const rows = [['Series', 'Label', 'Value']];\n\n    this.data.forEach(series => {\n      series.data.forEach(point => {\n        rows.push([series.name, point.label, point.value]);\n      });\n    });\n\n    return rows.map(row => row.join(',')).join('\\n');\n  }\n\n  /**\n   * Sets the theme for the graph.\n   * @param {string} theme - The theme name.\n   */\n  setTheme(theme) {\n    this.config = {\n      ...this.config,\n      ...this.themes[theme]\n    };\n    this.redrawGraph();\n  }\n\n  /**\n   * Checks and manages SVG element\n   * @private\n   * @returns {SVGElement} Ready-to-use SVG element\n   */\n  ensureSVG() {\n    try {\n      if (this.container.clientWidth === 0 || this.container.clientHeight === 0) {\n        // Container is not properly sized yet, schedule a retry\n        if (!this._waitingForSize) {\n          this._waitingForSize = true;\n          setTimeout(() => {\n            this._waitingForSize = false;\n            this.redrawGraph();\n          }, 100);\n        }\n        return null;\n      }\n\n      if (this.svg && this.container.contains(this.svg)) {\n        return this.svg;\n      }\n\n      // Create new SVG if it doesn't exist\n      this.createSVG();\n\n      return this.svg;\n\n    } catch (error) {\n      console.error('[GraphRenderer] Error ensuring SVG:', error);\n      throw error;\n    }\n  }\n};\n\n// Expose globally\nwindow.GraphRenderer = GraphRenderer;\n","/**\n* GraphComponent for Now.js Framework\n* Pure JavaScript implementation of basic charts with modular architecture\n*\n* Features:\n* - Line charts\n* - Bar charts\n* - Pie charts\n* - Donut charts\n* - Gauge charts\n* - SVG based rendering\n* - Tooltips\n* - Legends\n* - Responsive design\n* - Animation support\n*/\nconst GraphComponent = {\n  config: {\n    // Base options\n    autoload: true,\n    debug: false,\n\n    // Appearance options\n    colors: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F9ED69', '#F08A5D', '#B83B5E', '#6A2C70', '#00B8A9'],\n    backgroundColor: '#ffffff',\n    showGrid: true,\n    gridColor: '#E0E0E0',\n    axisColor: '#333333',\n    curve: true,\n    maxGaugeValue: 100,\n    centerText: null,\n    showCenterText: true,\n    gap: 2,\n    borderWidth: 1,\n    borderColor: 'auto',\n    pointRadius: 4,\n    lineWidth: 2,\n    fillArea: false,\n    fillOpacity: 0.1,\n\n    // Font options\n    fontFamily: 'Arial, sans-serif',\n    textColor: '#333333',\n    fontSize: 16,\n\n    // Component behavior\n    showAxisLabels: true,\n    showAxis: true,\n    animationDuration: 1000,\n    donutThickness: 30,\n    gaugeCurveWidth: 30,\n    showLegend: true,\n    legendPosition: 'bottom',\n    showTooltip: true,\n    tooltipFormatter: null,\n    showDataLabels: true,\n    showValueInsteadOfPercent: true,\n    animation: false,\n    maxDataPoints: 20,\n\n    // Data loading\n    type: 'line',\n    table: null,\n    url: null,\n    data: null,\n\n    // Event handlers\n    onClick: null,\n    onLoad: null,\n    onRender: null,\n    onDataChange: null,\n\n    // Refresh options\n    pollingInterval: 0,\n    refreshEvent: null\n  },\n\n  state: {\n    instances: new Map(),\n    initialized: false,\n    renderer: null,\n    pendingLoads: new Map(),\n    timers: new Map()\n  },\n\n  /**\n   * Initialize GraphComponent\n   * @param {Object} options - Configuration options\n   * @returns {Object} - GraphComponent instance\n   */\n  async init(options = {}) {\n    if (this.state.initialized) return this;\n\n    this.config = {...this.config, ...options};\n\n    // Initialize existing components\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', () => this.initElements());\n    } else {\n      this.initElements();\n    }\n\n    // Setup mutation observer to detect new graph components\n    this.setupObserver();\n\n    // Listen for locale changes to redraw graphs with new translations\n    if (window.EventManager?.on) {\n      this.state.localeChangeHandler = () => this.refreshAll();\n      EventManager.on('locale:changed', this.state.localeChangeHandler);\n    }\n\n    this.state.initialized = true;\n    return this;\n  },\n\n  /**\n   * Initialize all graph components in the document\n   */\n  initElements() {\n    document.querySelectorAll('[data-component=\"graph\"]').forEach(element => {\n      this.create(element);\n    });\n  },\n\n  /**\n   * Setup mutation observer to detect new graph components\n   */\n  setupObserver() {\n    const observer = new MutationObserver(mutations => {\n      mutations.forEach(mutation => {\n        mutation.addedNodes.forEach(node => {\n          if (node.nodeType === 1) {\n            // Check if the node is a graph component\n            if (node.dataset && node.dataset.component === 'graph') {\n              this.create(node);\n            }\n\n            // Check for graph components within the added node\n            const graphElements = node.querySelectorAll('[data-component=\"graph\"]');\n            graphElements.forEach(element => {\n              this.create(element);\n            });\n          }\n        });\n\n        // Handle removed nodes to clean up instances\n        mutation.removedNodes.forEach(node => {\n          if (node.nodeType === 1) {\n            // Wait for DOM operations to settle before cleanup\n            // This prevents premature cleanup when nodes are moved in DOM\n            setTimeout(() => {\n              if (node.dataset && node.dataset.component === 'graph') {\n                if (!node.isConnected) {\n                  this.destroy(node);\n                }\n              }\n\n              const graphElements = node.querySelectorAll('[data-component=\"graph\"]');\n              graphElements.forEach(element => {\n                if (!element.isConnected) {\n                  this.destroy(element);\n                }\n              });\n            }, 0);\n          }\n        });\n      });\n    });\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n  },\n\n  /**\n   * Create a new graph instance\n   * @param {HTMLElement|string} element - The container element or selector\n   * @param {Object} options - Configuration options\n   * @returns {Object} - Graph instance\n   */\n  async create(element, options = {}) {\n    // Handle selector strings\n    if (typeof element === 'string') {\n      element = document.querySelector(element);\n    }\n\n    if (!element) {\n      console.error('GraphComponent: Element not found');\n      return null;\n    }\n\n    // Check for existing instance\n    const existingInstance = this.getInstance(element);\n    if (existingInstance) {\n      return existingInstance;\n    }\n\n    // Extract options from data attributes\n    const dataOptions = this.extractOptionsFromElement(element);\n\n    // Merge options (priority: default < data attributes < passed options)\n    const mergedOptions = {...this.config, ...dataOptions, ...options};\n\n    // Create instance ID\n    const id = 'graph_' + Math.random().toString(36).substring(2, 11);\n\n    // Create instance object\n    const instance = {\n      id,\n      element,\n      options: mergedOptions,\n      data: null,\n      state: {\n        loading: false,\n        error: null,\n        rendered: false,\n        width: element.clientWidth,\n        height: element.clientHeight\n      },\n      renderer: null,\n      timer: null\n    };\n\n    // Mark element with ID\n    element.dataset.graphComponentId = id;\n    element.classList.add('graph-component');\n\n    // Store instance\n    this.state.instances.set(id, instance);\n\n    // Ensure renderer is loaded\n    await this.ensureRenderer();\n\n    // Setup the instance\n    this.setupInstance(instance);\n\n    // Load data if autoload is enabled\n    if (instance.options.autoload) {\n      this.loadData(instance);\n    }\n\n    // Setup polling if configured\n    if (instance.options.pollingInterval > 0 && instance.options.url) {\n      this.startPolling(instance);\n    }\n\n    // Setup refresh event if configured\n    if (instance.options.refreshEvent) {\n      this.bindRefreshEvent(instance);\n    }\n\n    // Store reference on element\n    element.graphInstance = instance;\n\n    // Dispatch created event\n    this.dispatchEvent(instance, 'created', {\n      instance\n    });\n\n    return instance;\n  },\n\n  /**\n   * Setup a graph instance with required methods and initial state\n   * @param {Object} instance - Graph instance to setup\n   */\n  setupInstance(instance) {\n    // Add methods to instance\n    instance.setData = (data) => this.setData(instance, data);\n    instance.loadData = (url) => this.loadData(instance, url);\n    instance.refresh = () => this.refresh(instance);\n    instance.addDataPoint = (point, seriesIndex) => this.addDataPoint(instance, point, seriesIndex);\n    instance.setType = (type) => this.setType(instance, type);\n    instance.exportToImage = (filename, format, width, height, quality, scale) =>\n      this.exportToImage(instance, filename, format, width, height, quality, scale);\n    instance.destroy = () => this.destroy(instance);\n\n    // Initialize renderer\n    instance.renderer = new this.state.renderer(instance.element, instance.options);\n\n    // Set initial data if provided\n    if (instance.options.data) {\n      this.setData(instance, instance.options.data);\n    } else if (instance.options.table) {\n      const table = document.getElementById(instance.options.table);\n      if (table) {\n        const data = this.loadAndProcessTableData(instance, table);\n        this.setData(instance, data);\n      }\n    }\n\n    // Setup resize handler\n    const resizeHandler = this.debounce(() => {\n      if (!instance.element) return;\n\n      const width = instance.element.clientWidth;\n      const height = instance.element.clientHeight;\n\n      if (width !== instance.state.width || height !== instance.state.height) {\n        instance.state.width = width;\n        instance.state.height = height;\n\n        if (instance.renderer) {\n          instance.renderer.handleResize();\n        }\n      }\n    }, 200);\n\n    window.addEventListener('resize', resizeHandler);\n    instance.resizeHandler = resizeHandler;\n  },\n\n  /**\n   * Ensure the renderer is loaded\n   * @returns {Promise} - Resolves when renderer is loaded\n   */\n  async ensureRenderer() {\n    if (this.state.renderer) {\n      return this.state.renderer;\n    }\n\n    // If GraphRenderer is already available globally\n    if (window.GraphRenderer) {\n      this.state.renderer = window.GraphRenderer;\n      return this.state.renderer;\n    }\n\n    // Otherwise, create a simplified renderer internally\n    this.state.renderer = this.createInternalRenderer();\n    return this.state.renderer;\n  },\n\n  /**\n   * Create internal renderer if external renderer is not available\n   * @returns {Class} - Graph renderer class\n   */\n  createInternalRenderer() {\n    return class InternalGraphRenderer {\n      constructor(element, options) {\n        this.element = element;\n        this.options = options;\n        this.svg = null;\n        this.width = element.clientWidth;\n        this.height = element.clientHeight;\n\n        // Create SVG\n        this.createSVG();\n      }\n\n      createSVG() {\n        if (this.width <= 0 || this.height <= 0) return;\n\n        this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        this.svg.setAttribute('width', '100%');\n        this.svg.setAttribute('height', '100%');\n        this.svg.setAttribute('viewBox', `0 0 ${this.width} ${this.height}`);\n        this.svg.setAttribute('role', 'img');\n        this.svg.setAttribute('aria-label', 'Data Visualization Graph');\n\n        this.element.appendChild(this.svg);\n      }\n\n      setData(data) {\n        this.data = data;\n        this.renderGraph();\n      }\n\n      renderGraph() {\n        if (!this.svg) this.createSVG();\n        this.svg.innerHTML = '';\n\n        // Display placeholder text indicating this is a simplified renderer\n        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        text.setAttribute('x', this.width / 2);\n        text.setAttribute('y', this.height / 2);\n        text.setAttribute('text-anchor', 'middle');\n        text.setAttribute('dominant-baseline', 'middle');\n        text.setAttribute('font-family', this.options.fontFamily);\n        text.setAttribute('font-size', '14px');\n        text.textContent = 'Graph Rendering (Full implementation required)';\n\n        this.svg.appendChild(text);\n      }\n\n      handleResize() {\n        if (!this.element) return;\n\n        this.width = this.element.clientWidth;\n        this.height = this.element.clientHeight;\n\n        if (this.svg) {\n          this.svg.setAttribute('viewBox', `0 0 ${this.width} ${this.height}`);\n          this.renderGraph();\n        }\n      }\n\n      destroy() {\n        if (this.svg && this.element.contains(this.svg)) {\n          this.element.removeChild(this.svg);\n        }\n      }\n    };\n  },\n\n  /**\n   * Set data for a graph instance\n   * @param {Object} instance - Graph instance\n   * @param {Array} data - Data to set\n   */\n  setData(instance, data) {\n    if (!instance || !data) return;\n\n    instance.data = data;\n\n    if (instance.renderer) {\n      instance.renderer.setData(data);\n      instance.state.rendered = true;\n\n      this.dispatchEvent(instance, 'data-changed', {\n        data: data\n      });\n\n      if (typeof instance.options.onDataChange === 'function') {\n        instance.options.onDataChange.call(instance, data);\n      }\n    }\n  },\n\n  /**\n   * Load data for a graph instance\n   * @param {Object} instance - Graph instance\n   * @param {string} [url] - URL to load data from (optional)\n   * @returns {Promise} - Resolves when data is loaded\n   */\n  async loadData(instance, url) {\n    if (!instance) return;\n\n    // Use provided URL or fallback to instance options\n    const dataUrl = url || instance.options.url;\n\n    // If we have direct data, use that instead\n    if (!dataUrl && instance.options.data) {\n      this.setData(instance, instance.options.data);\n      return;\n    }\n\n    // If we have a table, use that\n    if (!dataUrl && instance.options.table) {\n      const table = document.getElementById(instance.options.table);\n      if (table) {\n        const data = this.loadAndProcessTableData(instance, table);\n        this.setData(instance, data);\n        return;\n      }\n    }\n\n    // If no data source is available, return\n    if (!dataUrl) {\n      console.warn('GraphComponent: No data source specified');\n      return;\n    }\n\n    // Set loading state\n    instance.state.loading = true;\n    instance.state.error = null;\n    this.dispatchEvent(instance, 'loading');\n\n    try {\n      // Use window.http if available (preferred)\n      let response;\n      if (window.http && typeof window.http.get === 'function') {\n        response = await window.http.get(dataUrl);\n      } else if (window.simpleFetch && typeof window.simpleFetch.get === 'function') {\n        const requestHeaders = {\n          'Accept': 'application/json',\n          'X-Requested-With': 'XMLHttpRequest'\n        };\n        response = await simpleFetch.get(dataUrl, {headers: requestHeaders});\n      } else {\n        throw new Error('HttpClient (window.http) or simpleFetch is required');\n      }\n\n      // Handle response data\n      // window.http returns the full response object, simpleFetch might return data directly\n      let data = response.data || response;\n\n      // Unwrap 'data' property if present (common in API responses)\n      if (data && data.data) {\n        data = data.data;\n      }\n\n      // Unwrap another 'data' property if present (nested structure from dashboard.php)\n      // structure: { success: true, data: { data: [...] } } -> we are at { data: [...] }\n      if (data && data.data && Array.isArray(data.data)) {\n        data = data.data;\n      }\n\n      // If there's a path option, extract nested data\n      if (instance.options.path) {\n        const path = instance.options.path;\n        const keys = path.split('.');\n        for (const key of keys) {\n          if (data && typeof data === 'object' && key in data) {\n            data = data[key];\n          } else {\n            console.warn(`GraphComponent: Path \"${path}\" not found in response data`);\n            data = null;\n            break;\n          }\n        }\n      }\n\n      // Set the data\n      if (data) {\n        this.setData(instance, data);\n      }\n\n      // Update state\n      instance.state.loading = false;\n\n      // Dispatch loaded event\n      this.dispatchEvent(instance, 'loaded', {\n        data: data\n      });\n\n      // Call onLoad callback if provided\n      if (typeof instance.options.onLoad === 'function') {\n        instance.options.onLoad.call(instance, data);\n      }\n\n      return data;\n\n    } catch (error) {\n      // Ignore AbortError as it's not a real error\n      if (error.name === 'AbortError') {\n        return;\n      }\n\n      // Handle other errors\n      instance.state.loading = false;\n      instance.state.error = error.message;\n\n      this.dispatchEvent(instance, 'error', {\n        error: error\n      });\n\n      console.error('GraphComponent: Error loading data', error);\n    }\n  },\n\n  /**\n   * Add a single data point to a graph\n   * @param {Object} instance - Graph instance\n   * @param {Object} point - Data point to add\n   * @param {number} [seriesIndex=0] - Index of the series to add the point to\n   */\n  addDataPoint(instance, point, seriesIndex = 0) {\n    if (!instance || !instance.renderer) return;\n\n    instance.renderer.addDataPoint(point, seriesIndex);\n\n    this.dispatchEvent(instance, 'data-point-added', {\n      point,\n      seriesIndex\n    });\n  },\n\n  /**\n   * Change the chart type\n   * @param {Object} instance - Graph instance\n   * @param {string} type - New chart type (line, bar, pie, donut, gauge)\n   */\n  setType(instance, type) {\n    if (!instance || !instance.renderer) return;\n\n    // Update the options\n    instance.options.type = type;\n\n    // If we can update the renderer's type directly\n    if (instance.renderer.currentChartType !== undefined) {\n      instance.renderer.currentChartType = type;\n      instance.renderer.redrawGraph();\n    } else {\n      // Otherwise, recreate the renderer\n      instance.renderer.destroy();\n      instance.renderer = new this.state.renderer(instance.element, instance.options);\n\n      if (instance.data) {\n        instance.renderer.setData(instance.data);\n      }\n    }\n\n    this.dispatchEvent(instance, 'type-changed', {\n      type\n    });\n  },\n\n  /**\n   * Export the graph to an image file\n   * @param {Object} instance - Graph instance\n   * @param {string} [filename='graph'] - The base name of the exported file\n   * @param {string} [format='png'] - The image format ('png', 'jpeg', or 'svg')\n   * @param {number} [width] - The width of the exported image\n   * @param {number} [height] - The height of the exported image\n   * @param {number} [quality=0.8] - The quality for JPEG format\n   * @param {number} [scale=1] - The scale factor for the exported image\n   */\n  exportToImage(instance, filename = 'graph', format = 'png', width, height, quality = 0.8, scale = 1) {\n    if (!instance || !instance.renderer) return;\n\n    if (typeof instance.renderer.exportToImage === 'function') {\n      return instance.renderer.exportToImage(filename, format, width, height, quality, scale);\n    } else {\n      console.warn('GraphComponent: Export to image not supported by this renderer');\n    }\n  },\n\n  /**\n   * Refresh a graph instance\n   * @param {Object|string} instance - Graph instance or ID\n   */\n  refresh(instance) {\n    // Handle string ID\n    if (typeof instance === 'string') {\n      instance = this.state.instances.get(instance);\n    } else if (instance instanceof HTMLElement) {\n      instance = this.getInstance(instance);\n    }\n\n    if (!instance) return;\n\n    this.loadData(instance);\n  },\n\n  /**\n   * Refresh all graph instances\n   * Used when language changes to update labels and translations\n   */\n  refreshAll() {\n    this.state.instances.forEach(instance => {\n      this.loadData(instance);\n    });\n  },\n\n  /**\n   * Start polling for data updates\n   * @param {Object} instance - Graph instance\n   */\n  startPolling(instance) {\n    if (!instance || !instance.options.url || instance.options.pollingInterval <= 0) return;\n\n    // Clear existing timer if any\n    this.stopPolling(instance);\n\n    // Create new timer\n    const timer = setInterval(() => {\n      if (!instance.state.loading) {\n        this.loadData(instance);\n      }\n    }, instance.options.pollingInterval);\n\n    // Store timer\n    this.state.timers.set(instance.id, timer);\n    instance.timer = timer;\n\n    this.dispatchEvent(instance, 'polling-started', {\n      interval: instance.options.pollingInterval\n    });\n  },\n\n  /**\n   * Stop polling for data updates\n   * @param {Object} instance - Graph instance\n   */\n  stopPolling(instance) {\n    if (!instance) return;\n\n    const timer = this.state.timers.get(instance.id);\n    if (timer) {\n      clearInterval(timer);\n      this.state.timers.delete(instance.id);\n      instance.timer = null;\n\n      this.dispatchEvent(instance, 'polling-stopped');\n    }\n  },\n\n  /**\n   * Bind refresh event to the instance\n   * @param {Object} instance - Graph instance\n   */\n  bindRefreshEvent(instance) {\n    if (!instance || !instance.options.refreshEvent) return;\n\n    const events = instance.options.refreshEvent.split(',').map(e => e.trim());\n    instance.eventHandlers = [];\n\n    events.forEach(eventName => {\n      const handler = () => this.refresh(instance);\n\n      // Store handler for cleanup\n      instance.eventHandlers.push({eventName, handler});\n\n      // Register with event manager if available\n      EventManager.on(eventName, handler);\n    });\n  },\n\n  /**\n   * Unbind refresh events from an instance\n   * @param {Object} instance - Graph instance\n   */\n  unbindRefreshEvent(instance) {\n    if (!instance || !instance.eventHandlers) return;\n\n    instance.eventHandlers.forEach(({eventName, handler}) => {\n      EventManager.off(eventName, handler);\n    });\n\n    instance.eventHandlers = [];\n  },\n\n  /**\n   * Get a graph instance by element or ID\n   * @param {HTMLElement|string} element - Element or ID\n   * @returns {Object|null} - Graph instance or null if not found\n   */\n  getInstance(element) {\n    // Handle direct ID lookup\n    if (typeof element === 'string') {\n      return this.state.instances.get(element);\n    }\n\n    // Handle element lookup\n    if (element instanceof HTMLElement) {\n      // Check for direct reference\n      if (element.graphInstance) {\n        return element.graphInstance;\n      }\n\n      // Check for ID in dataset\n      const id = element.dataset.graphComponentId;\n      if (id && this.state.instances.has(id)) {\n        return this.state.instances.get(id);\n      }\n\n      // Scan all instances\n      for (const [id, instance] of this.state.instances.entries()) {\n        if (instance.element === element) {\n          return instance;\n        }\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Extract options from an element's data attributes\n   * @param {HTMLElement} element - Element to extract options from\n   * @returns {Object} - Extracted options\n   */\n  extractOptionsFromElement(element) {\n    const options = {};\n    const dataset = element.dataset;\n\n    // Try to parse data-props first (JSON format)\n    if (dataset.props) {\n      try {\n        const props = JSON.parse(dataset.props);\n        Object.assign(options, props);\n      } catch (e) {\n        console.warn('GraphComponent: Invalid JSON in data-props', e);\n      }\n    }\n\n    // Process individual data-* attributes\n    for (const [key, value] of Object.entries(dataset)) {\n      if (key === 'component' || key === 'props' || key === 'graphComponentId') continue;\n\n      const optionKey = this.kebabToCamel(key);\n      options[optionKey] = this.parseDataValue(value);\n    }\n\n    return options;\n  },\n\n  /**\n   * Convert kebab-case to camelCase\n   * @param {string} str - Kebab-case string\n   * @returns {string} - CamelCase string\n   */\n  kebabToCamel(str) {\n    return str.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase());\n  },\n\n  /**\n   * Parse a data attribute value to the appropriate type\n   * @param {string} value - Data attribute value\n   * @returns {*} - Parsed value\n   */\n  parseDataValue(value) {\n    // Boolean values\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n\n    // Numeric values\n    if (!isNaN(value) && value.trim() !== '') return Number(value);\n\n    // Array or object (JSON)\n    try {\n      if ((value.startsWith('[') && value.endsWith(']')) ||\n        (value.startsWith('{') && value.endsWith('}'))) {\n        return JSON.parse(value);\n      }\n    } catch (e) {\n      // If parsing fails, return as string\n    }\n\n    // Default: return as string\n    return value;\n  },\n\n  /**\n   * Dispatch an event from an instance\n   * @param {Object} instance - Graph instance\n   * @param {string} eventName - Event name\n   * @param {Object} detail - Event details\n   */\n  dispatchEvent(instance, eventName, detail = {}) {\n    if (!instance || !instance.element) return;\n\n    // Create and dispatch DOM event\n    const event = new CustomEvent(`graph:${eventName}`, {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        instance,\n        ...detail\n      }\n    });\n\n    instance.element.dispatchEvent(event);\n\n    EventManager.emit(`graph:${eventName}`, {\n      instance,\n      ...detail\n    });\n  },\n\n  /**\n   * Load and process data from an HTML table\n   * @param {Object} instance - Graph instance\n   * @param {HTMLTableElement} table - Table element\n   * @returns {Array} - Processed data\n   */\n  loadAndProcessTableData(instance, table) {\n    if (!table) return [];\n\n    // If renderer has this method, use it\n    if (instance.renderer && typeof instance.renderer.loadAndProcessTableData === 'function') {\n      return instance.renderer.loadAndProcessTableData(table);\n    }\n\n    // Otherwise use our implementation\n    const headerRow = table.querySelector('thead > tr');\n    const dataRows = table.querySelectorAll('tbody > tr');\n\n    if (!headerRow || !dataRows.length) return [];\n\n    // Get column headers (skip first which is usually row labels)\n    const headers = Array.from(headerRow.querySelectorAll('th')).slice(1).map(th => th.innerHTML);\n\n    // Process each data row\n    const result = [];\n    dataRows.forEach(row => {\n      const seriesName = row.querySelector('th')?.textContent.trim() || '';\n      const cells = row.querySelectorAll('td');\n\n      const seriesData = [];\n      cells.forEach((cell, index) => {\n        if (index < headers.length) {\n          seriesData.push({\n            label: headers[index],\n            value: parseFloat(cell.textContent.replace(/,/g, '')) || 0\n          });\n        }\n      });\n\n      if (seriesData.length > 0) {\n        result.push({\n          name: seriesName,\n          data: seriesData\n        });\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * Debounce a function\n   * @param {Function} func - Function to debounce\n   * @param {number} wait - Debounce wait time in milliseconds\n   * @returns {Function} - Debounced function\n   */\n  debounce(func, wait) {\n    let timeout;\n    return function(...args) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => func.apply(this, args), wait);\n    };\n  },\n\n  /**\n   * Destroy a graph instance\n   * @param {Object|string|HTMLElement} instance - Graph instance, ID, or element\n   * @returns {boolean} - Success status\n   */\n  destroy(instance) {\n    // Handle string ID\n    if (typeof instance === 'string') {\n      instance = this.state.instances.get(instance);\n    } else if (instance instanceof HTMLElement) {\n      instance = this.getInstance(instance);\n    }\n\n    if (!instance) return false;\n\n    // Stop polling if active\n    this.stopPolling(instance);\n\n    // Unbind event handlers\n    this.unbindRefreshEvent(instance);\n\n    // Cancel any pending loads\n    const pendingLoad = this.state.pendingLoads.get(instance.id);\n    if (pendingLoad) {\n      const apiService = window.ApiService || window.Now?.getManager?.('api');\n      if (pendingLoad.type === 'api' && apiService?.abort) {\n        apiService.abort(pendingLoad.url, pendingLoad.params || {});\n      }\n      this.state.pendingLoads.delete(instance.id);\n    }\n\n    // Remove resize handler\n    if (instance.resizeHandler) {\n      window.removeEventListener('resize', instance.resizeHandler);\n    }\n\n    // Clean up renderer\n    if (instance.renderer) {\n      instance.renderer.destroy();\n    }\n\n    // Clean up DOM\n    if (instance.element) {\n      delete instance.element.graphInstance;\n      delete instance.element.dataset.graphComponentId;\n      instance.element.classList.remove('graph-component');\n    }\n\n    // Dispatch destroy event\n    this.dispatchEvent(instance, 'destroyed');\n\n    // Remove from instances map\n    this.state.instances.delete(instance.id);\n\n    return true;\n  },\n\n  /**\n   * Destroy all graph instances\n   */\n  destroyAll() {\n    for (const id of this.state.instances.keys()) {\n      this.destroy(id);\n    }\n  }\n};\n\n// Register with Now.js framework\nif (window.Now?.registerManager) {\n  Now.registerManager('graph', GraphComponent);\n}\n\n// Register with ComponentManager if available\nif (window.ComponentManager) {\n  ComponentManager.define('graph', {\n    template: null,\n\n    validElement(element) {\n      return element.classList.contains('graph-component') ||\n        element.dataset.component === 'graph';\n    },\n\n    setupElement(element, state) {\n      const options = {};\n\n      // Extract options from element\n      if (element.dataset.props) {\n        try {\n          const props = JSON.parse(element.dataset.props);\n          Object.assign(options, props);\n        } catch (e) {\n          console.warn('Invalid props JSON', e);\n        }\n      }\n\n      // Create graph component\n      const graph = GraphComponent.create(element, options);\n\n      // Store reference\n      element._graphComponent = graph;\n      return element;\n    },\n\n    beforeDestroy() {\n      if (this.element && this.element._graphComponent) {\n        GraphComponent.destroy(this.element._graphComponent);\n        delete this.element._graphComponent;\n      }\n    }\n  });\n}\n\n// Expose globally\nwindow.GraphComponent = GraphComponent;\n"],"names":["window","GraphRenderer","constructor","container","options","__publicField","this","light","backgroundColor","textColor","gridColor","axisColor","dark","Error","width","clientWidth","height","clientHeight","containerStyles","getComputedStyle","defaultFontSize","parseInt","fontSize","defaultFontFamily","fontFamily","defaultTextColor","color","defaultBackgroundColor","defaultConfig","colors","showGrid","curve","maxGaugeValue","centerText","showCenterText","gap","borderWidth","borderColor","pointRadius","lineWidth","fillArea","fillOpacity","isNaN","showAxisLabels","showAxis","animationDuration","donutThickness","gaugeCurveWidth","showLegend","legendPosition","showTooltip","tooltipFormatter","showDataLabels","showValueInsteadOfPercent","animation","maxDataPoints","type","table","data","onClick","fontUrl","readConfigFromDataAttributes","config","configFromData","minValue","maxValue","currentChartType","legend","state","initialized","validateOptions","calculateFontSize","setMargins","visibleDataCount","calculateVisibleDataCount","createSVG","initialize","setData","renderGraph","svg","handleResize","debounce","bind","addEventListener","dataAttributes","dataset","key","hasOwnProperty","configKey","kebabToCamel","value","parseConfigValue","str","replace","match","letter","toUpperCase","Number","JSON","parse","e","Array","isArray","TypeError","createSVGElement","viewBox","role","tabindex","handleKeyboardNavigation","desc","textContent","getAccessibilityDescription","appendChild","event","length","attributes","elem","document","createElementNS","Object","keys","forEach","attr","setAttribute","clear","contains","removeChild","func","wait","timeout","args","clearTimeout","setTimeout","apply","_a","_b","labelFontSize","minDimension","Math","min","max","newWidth","newHeight","redrawGraph","_waitingForSize","loadAndProcessTableData","tableData","loadFromTable","processTableData","rawData","headers","title","items","rows","querySelectorAll","cell","index","trim","push","innerHTML","tr","row","tagName","parseFloat","processedData","rowIndex","series","name","header","colIndex","label","tooltip","formatValue","validateData","allValues","flatMap","map","point","calculateNiceRange","error","console","EventManager","emit","pointIndex","range","minNice","maxNice","roughStep","magnitude","pow","floor","log10","niceStep","ceil","drawAxes","axesGroup","class","yBase","xAxis","x1","margin","left","y1","getPointY","x2","right","y2","stroke","yAxis","top","bottom","drawYAxisLabels","i","y","x","fill","drawVerticalGridLines","xPositions","gridGroup","line","drawHorizontalGridLines","gridLine","drawLabel","text","rotate","addAnimation","element","animate","entries","ensureSVG","firstChild","previousAnimation","drawLineGraph","drawBarGraph","drawPieChart","drawGauge","drawLegend","getPointX","availableWidth","availableHeight","getLinearPath","join","getCurvePath","path","describeArc","radius","startAngle","endAngle","start","polarToCartesian","end","largeArcFlag","PI","centerX","centerY","angleInRadians","cos","sin","addDataPoint","newData","seriesIndex","removed","shift","seriesCount","steps","xPositionsSet","Set","add","from","labels","slice","stripTags","labelText","estimateTextWidth","lineGroup","clipPathId","Date","now","clipPath","id","clipRect","animateClip","attributeName","to","dur","linePath","d","fillPath","fillY","finalD","getAttribute","initialD","animateFill","getTotalLength","style","cursor","pointsGroup","horizontalLineLength","verticalLineXEnd","verticalLineYEnd","lineVertical","animateVerticalLine","animateHorizontalLine","horizontalLineXEnd","lineHorizontal","begin","getLabelContent","animateOpacity","animatePosition","circle","cx","cy","r","getTooltipContent","animateRadius","groupWidth","barWidth","barGap","zeroY","defs","filter","feOffset","dx","dy","result","feGaussianBlur","in","stdDeviation","feFlood","feComposite","in2","operator","feMerge","feMergeNode1","feMergeNode2","yValue","abs","bar","darkenColor","yForm","animHeight","animY","animLabelY","isDonut","total","reduce","sum","s","p","warn","pieGroup","sliceAngle","midAngle","pathData","pathLength","animateSlice","labelRadius","labelX","labelY","animateVerticalLineX","donutHole","background","percentage","valueAngle","valuePath","animateGauge","parentElement","createElement","className","display","justifyContent","flexWrap","columnGap","item","createLegendItem","insertBefore","webkitBoxOrient","webkitLineClamp","overflow","colorBox","borderRadius","marginRight","getTotal","html","div","innerText","parts","toFixed","toString","split","tempText","bbox","getBBox","includes","hex","factor","startsWith","c","round","g","b","padStart","getElementById","destroy","removeEventListener","throttle","limit","inThrottle","properties","duration","animations","prop","easing","Promise","all","a","finished","getPathLength","tempPath","remove","handleTouchStart","touchStartX","touches","clientX","touchStartY","clientY","handleTouchMove","xDiff","yDiff","pan","zoom","handleTouchEnd","exportToImage","filename","format","quality","scale","originalAnimations","disableAnimations","aspectRatio","exportWidth","exportHeight","svgClone","cloneNode","insertAdjacentHTML","svgString","XMLSerializer","serializeToString","restoreAnimations","svgBlob","Blob","url","URL","createObjectURL","link","download","href","body","click","revokeObjectURL","svgDataUrl","encodeURIComponent","canvas","ctx","getContext","img","Image","onload","fillStyle","fillRect","drawImage","mimeType","imageDataUrl","toDataURL","onerror","src","animateElements","getElementsByTagName","parent","toValue","animateTransforms","exportToCSV","setTheme","theme","themes","GraphComponent","autoload","debug","onLoad","onRender","onDataChange","pollingInterval","refreshEvent","instances","Map","renderer","pendingLoads","timers","init","readyState","initElements","setupObserver","on","localeChangeHandler","refreshAll","create","MutationObserver","mutations","mutation","addedNodes","node","nodeType","component","removedNodes","isConnected","observe","childList","subtree","querySelector","existingInstance","getInstance","dataOptions","extractOptionsFromElement","mergedOptions","random","substring","instance","loading","rendered","timer","graphComponentId","classList","set","ensureRenderer","setupInstance","loadData","startPolling","bindRefreshEvent","graphInstance","dispatchEvent","refresh","setType","resizeHandler","createInternalRenderer","InternalGraphRenderer","call","dataUrl","response","http","get","simpleFetch","requestHeaders","Accept","message","HTMLElement","stopPolling","setInterval","interval","clearInterval","delete","events","eventHandlers","eventName","handler","unbindRefreshEvent","off","has","props","assign","parseDataValue","endsWith","detail","CustomEvent","bubbles","cancelable","headerRow","dataRows","th","seriesName","cells","seriesData","pendingLoad","apiService","ApiService","Now","getManager","abort","params","destroyAll","registerManager","ComponentManager","define","template","validElement","setupElement","graph","_graphComponent","beforeDestroy"],"mappings":"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"}