{"version":3,"file":"now.queue.min.js","sources":["../js/QueueManager.js"],"sourcesContent":["/**\n * QueueManager\n * A versatile queue management system for handling tasks asynchronously\n * with priority, retry, and rate limiting\n *\n * Features:\n * - Multiple queue types (FIFO, priority, delayed)\n * - Task prioritization\n * - Concurrency control\n * - Retry mechanisms with backoff\n * - Rate limiting\n * - Persistence option (uses StorageManager)\n * - Worker pool management\n * - Enable/disable functionality\n */\nconst QueueManager = {\n  config: {\n    debug: false,\n    enabled: false,\n    defaultConcurrency: 5,\n    defaultMaxRetries: 3,\n    defaultRetryDelay: 1000,\n    defaultBackoffStrategy: 'exponential', // fixed, linear, exponential\n    defaultTimeout: 30000,\n    persistence: {\n      enabled: false,\n      storeName: 'queued_tasks',\n      syncInterval: 5000,\n      maxPersistedTasks: 1000\n    },\n    rateLimiting: {\n      enabled: false,\n      limit: 10, // tasks per interval\n      interval: 1000, // milliseconds\n      fairness: true // distribute rate limits fairly across queues\n    },\n    workerPool: {\n      enabled: true,\n      size: navigator.hardwareConcurrency || 4,\n      idleTimeout: 60000\n    }\n  },\n\n  state: {\n    initialized: false,\n    enabled: false,\n    queues: new Map(),\n    workers: [],\n    activeWorkers: 0,\n    runningTasks: new Map(),\n    taskCounter: 0,\n    persistenceTimer: null,\n    rateLimitCounter: 0,\n    rateLimitResetTime: 0,\n    pausedQueues: new Set(),\n    statistics: {\n      processed: 0,\n      succeeded: 0,\n      failed: 0,\n      retried: 0,\n      avgProcessingTime: 0\n    }\n  },\n\n  /**\n   * Initialize the QueueManager\n   * @param {Object} options - Configuration options\n   * @returns {Promise<QueueManager>} - Returns the QueueManager instance\n   */\n  async init(options = {}) {\n    try {\n      this.config = {...this.config, ...options};\n\n      if (this.config.persistence.enabled) {\n        this.storageManager = window.Now?.getManager('storage');\n\n        if (this.storageManager) {\n          if (!this.storageManager.state.initialized) {\n            try {\n              await this.storageManager.init();\n            } catch (storageError) {\n              console.error('Failed to initialize StorageManager:', storageError);\n              console.warn('StorageManager initialization failed, persistence disabled');\n              this.config.persistence.enabled = false;\n            }\n          }\n\n          if (this.config.persistence.enabled) {\n            try {\n              await this.storageManager.createDatabase({\n                name: this.storageManager.config.defaultDB,\n                version: this.storageManager.config.defaultVersion,\n                stores: {\n                  [this.config.persistence.storeName]: {\n                    keyPath: 'id',\n                    autoIncrement: true,\n                    indexes: [\n                      {name: 'queueName', keyPath: 'queueName'},\n                      {name: 'priority', keyPath: 'priority'},\n                      {name: 'scheduledTime', keyPath: 'scheduledTime'}\n                    ]\n                  }\n                }\n              });\n\n              await this.loadPersistedTasks();\n            } catch (dbError) {\n              console.error('Failed to create database for QueueManager:', dbError);\n              console.warn('Queue persistence setup failed, persistence disabled');\n              this.config.persistence.enabled = false;\n            }\n          }\n        } else {\n          console.warn('StorageManager not found, persistence disabled');\n          this.config.persistence.enabled = false;\n        }\n      }\n\n      if (this.config.workerPool.enabled) {\n        this.initWorkerPool();\n      }\n\n      this.state.initialized = true;\n\n      EventManager.emit('queue:ready', {manager: 'QueueManager'});\n\n      return this;\n    } catch (error) {\n      console.error('QueueManager initialization failed:', error);\n      if (window.ErrorManager) {\n        ErrorManager.handle(error, {\n          context: 'QueueManager.init',\n          type: 'queue:error'\n        });\n      }\n      throw error;\n    }\n  },\n\n  async enable() {\n    if (!this.state.initialized) {\n      await this.init();\n    }\n\n    this.state.enabled = true;\n    this.config.enabled = true;\n\n    if (this.config.persistence.enabled) {\n      this.startPersistenceSync();\n    }\n\n    for (const queueName of this.state.queues.keys()) {\n      this.processNextTasks(queueName);\n    }\n\n    EventManager.emit('queue:enabled');\n\n    return this;\n  },\n\n  disable() {\n    this.state.enabled = false;\n    this.config.enabled = false;\n\n    if (this.state.persistenceTimer) {\n      clearInterval(this.state.persistenceTimer);\n      this.state.persistenceTimer = null;\n    }\n\n    this.state.workers.forEach(worker => {\n      worker.busy = false;\n      worker.task = null;\n    });\n\n    EventManager.emit('queue:disabled');\n\n    return this;\n  },\n\n  /**\n   * Create a new queue\n   * @param {string} name - Queue name\n   * @param {Object} options - Queue options\n   * @returns {Object} - Queue reference\n   */\n  createQueue(name, options = {}) {\n    if (this.state.queues.has(name)) {\n      if (this.config.debug) {\n        console.warn(`Queue \"${name}\" already exists`);\n      }\n      return this.getQueue(name);\n    }\n\n    const queue = {\n      name,\n      tasks: [],\n      options: {\n        concurrency: this.config.defaultConcurrency,\n        maxRetries: this.config.defaultMaxRetries,\n        retryDelay: this.config.defaultRetryDelay,\n        backoffStrategy: this.config.defaultBackoffStrategy,\n        timeout: this.config.defaultTimeout,\n        priority: false,\n        fifo: true,\n        paused: false,\n        ...options\n      },\n      activeTasks: 0,\n      isProcessing: false\n    };\n\n    this.state.queues.set(name, queue);\n\n    EventManager.emit('queue:created', {name, options: queue.options});\n\n    return this.getQueueInterface(name);\n  },\n\n  /**\n   * Get a queue interface\n   * @param {string} name - Queue name\n   * @returns {Object} - Queue interface\n   */\n  getQueue(name) {\n    if (!this.state.queues.has(name)) {\n      throw new Error(`Queue \"${name}\" does not exist`);\n    }\n\n    return this.getQueueInterface(name);\n  },\n\n  /**\n   * Create a queue interface with methods for specific queue\n   * @param {string} name - Queue name\n   * @returns {Object} - Queue interface\n   * @private\n   */\n  getQueueInterface(name) {\n    return {\n      add: (task, options) => this.addTask(name, task, options),\n      addBulk: (tasks, options) => this.addBulkTasks(name, tasks, options),\n      pause: () => this.pauseQueue(name),\n      resume: () => this.resumeQueue(name),\n      clear: () => this.clearQueue(name),\n      getStats: () => this.getQueueStats(name),\n      getLength: () => this.getQueueLength(name),\n      setPriority: (priority) => this.setQueuePriority(name, priority),\n      setConcurrency: (concurrency) => this.setQueueConcurrency(name, concurrency),\n      getName: () => name,\n      isPaused: () => this.isQueuePaused(name),\n      isEnabled: () => this.config.enabled && this.state.enabled\n    };\n  },\n\n  /**\n   * Add a task to a queue\n   * @param {string} queueName - Queue name\n   * @param {Function|Object} task - Task function or object\n   * @param {Object} options - Task options\n   * @returns {string} - Task ID\n   */\n  addTask(queueName, task, options = {}) {\n    if (!this.config.enabled || !this.state.enabled) {\n      throw new Error('QueueManager is disabled');\n    }\n\n    if (!this.state.initialized) {\n      throw new Error('QueueManager is not initialized');\n    }\n\n    if (!this.state.queues.has(queueName)) {\n      this.createQueue(queueName);\n    }\n\n    const queue = this.state.queues.get(queueName);\n    const taskId = `task_${++this.state.taskCounter}_${Date.now()}`;\n\n    const isFunction = typeof task === 'function';\n\n    const taskObject = {\n      id: taskId,\n      queueName,\n      callback: isFunction ? task : null,\n      data: isFunction ? null : task,\n      priority: options.priority !== undefined ? options.priority : 0,\n      scheduledTime: options.delay ? Date.now() + options.delay : Date.now(),\n      attempts: 0,\n      maxRetries: options.maxRetries !== undefined ? options.maxRetries : queue.options.maxRetries,\n      retryDelay: options.retryDelay !== undefined ? options.retryDelay : queue.options.retryDelay,\n      backoffStrategy: options.backoffStrategy || queue.options.backoffStrategy,\n      timeout: options.timeout !== undefined ? options.timeout : queue.options.timeout,\n      createdAt: Date.now()\n    };\n\n    queue.tasks.push(taskObject);\n\n    if (queue.options.priority) {\n      this.sortQueueByPriority(queue);\n    }\n\n    if (!options.delay && !queue.options.paused && queue.activeTasks < queue.options.concurrency) {\n      this.processNextTasks(queueName);\n    }\n\n    if (this.config.persistence.enabled && this.storageManager) {\n      this.persistTask(taskObject);\n    }\n\n    EventManager.emit('queue:task:added', {\n      queueName,\n      taskId,\n      scheduled: options.delay ? new Date(taskObject.scheduledTime) : new Date()\n    });\n\n    return taskId;\n  },\n\n  /**\n   * Add multiple tasks to a queue\n   * @param {string} queueName - Queue name\n   * @param {Array} tasks - Array of tasks\n   * @param {Object} options - Task options\n   * @returns {Array} - Array of task IDs\n   */\n  addBulkTasks(queueName, tasks, options = {}) {\n    if (!Array.isArray(tasks)) {\n      throw new Error('Tasks must be an array');\n    }\n\n    return tasks.map(task => this.addTask(queueName, task, options));\n  },\n\n  /**\n   * Sort queue tasks by priority\n   * @param {Object} queue - Queue object\n   * @private\n   */\n  sortQueueByPriority(queue) {\n    queue.tasks.sort((a, b) => {\n      if (a.priority !== b.priority) {\n        return a.priority - b.priority;\n      }\n      return a.scheduledTime - b.scheduledTime;\n    });\n  },\n\n  /**\n   * Process next available tasks from a queue\n   * @param {string} queueName - Queue name\n   * @private\n   */\n  async processNextTasks(queueName) {\n    if (!this.config.enabled || !this.state.enabled) {\n      return;\n    }\n\n    if (!this.state.queues.has(queueName)) {\n      return;\n    }\n\n    const queue = this.state.queues.get(queueName);\n\n    if (queue.options.paused || queue.activeTasks >= queue.options.concurrency) {\n      return;\n    }\n\n    const now = Date.now();\n    const availableTasks = queue.tasks.filter(task => task.scheduledTime <= now);\n\n    if (availableTasks.length === 0) {\n      return;\n    }\n\n    if (this.config.rateLimiting.enabled) {\n      if (now > this.state.rateLimitResetTime) {\n        this.state.rateLimitCounter = 0;\n        this.state.rateLimitResetTime = now + this.config.rateLimiting.interval;\n      }\n\n      if (this.state.rateLimitCounter >= this.config.rateLimiting.limit) {\n        setTimeout(() => {\n          this.processNextTasks(queueName);\n        }, this.state.rateLimitResetTime - now);\n        return;\n      }\n    }\n\n    const tasksToProcess = Math.min(\n      availableTasks.length,\n      queue.options.concurrency - queue.activeTasks\n    );\n\n    if (tasksToProcess <= 0) {\n      return;\n    }\n\n    if (this.config.rateLimiting.enabled) {\n      this.state.rateLimitCounter += tasksToProcess;\n    }\n\n    for (let i = 0; i < tasksToProcess; i++) {\n      const taskIndex = queue.tasks.findIndex(task => task.scheduledTime <= now);\n\n      if (taskIndex === -1) {\n        break;\n      }\n\n      const task = queue.tasks.splice(taskIndex, 1)[0];\n\n      if (this.config.workerPool.enabled) {\n        queue.activeTasks++;\n        this.submitTaskToWorkerPool(task);\n      } else {\n        this.processTask(task);\n      }\n    }\n  },\n\n  /**\n   * Actually process a task\n   * @param {Object} task - Task object\n   * @returns {Promise<void>}\n   * @private\n   */\n  async processTask(task) {\n    const queue = this.state.queues.get(task.queueName);\n\n    if (!queue) {\n      return;\n    }\n\n    queue.activeTasks++;\n    this.state.runningTasks.set(task.id, task);\n\n    const timeoutId = setTimeout(() => {\n      this.handleTaskTimeout(task);\n    }, task.timeout);\n\n    const startTime = performance.now();\n\n    try {\n      EventManager.emit('queue:task:started', {\n        queueName: task.queueName,\n        taskId: task.id,\n        attempt: task.attempts + 1\n      });\n\n      task.attempts++;\n\n      let result;\n      if (task.callback) {\n        result = await Promise.resolve(task.callback(task.data));\n      } else if (task.data && task.data.url) {\n        result = await this.executeApiTask(task);\n      } else {\n        result = await this.executeEventTask(task);\n      }\n\n      clearTimeout(timeoutId);\n      await this.handleTaskSuccess(task, result, performance.now() - startTime);\n\n    } catch (error) {\n      clearTimeout(timeoutId);\n      await this.handleTaskError(task, error, performance.now() - startTime);\n    } finally {\n      this.state.runningTasks.delete(task.id);\n      queue.activeTasks--;\n      this.processNextTasks(task.queueName);\n    }\n  },\n\n  /**\n   * Execute a task that makes an API request\n   * @param {Object} task - Task object\n   * @returns {Promise<any>} - API response\n   * @private\n   */\n  async executeApiTask(task) {\n    const {url, method = 'GET', data, headers = {}} = task.data;\n    const methodLower = method.toLowerCase();\n\n    const apiService = window.ApiService || window.Now?.getManager?.('api');\n    if (apiService && typeof apiService[methodLower] === 'function') {\n      return apiService[methodLower](url, data, {headers});\n    }\n\n    if (window.http && typeof window.http[methodLower] === 'function') {\n      return window.http[methodLower](url, data, {headers});\n    }\n\n    if (window.simpleFetch && typeof window.simpleFetch[methodLower] === 'function') {\n      return window.simpleFetch[methodLower](url, data, {headers});\n    }\n\n    throw new Error('No HTTP client available to execute API task');\n  },\n\n  /**\n   * Execute a task that emits an event\n   * @param {Object} task - Task object\n   * @returns {Promise<any>} - Event result\n   * @private\n   */\n  async executeEventTask(task) {\n    const {event, data} = task.data || {};\n\n    if (!event) {\n      throw new Error('Event name is required for event tasks');\n    }\n\n    return EventManager.emit(event, data || {});\n  },\n\n  /**\n   * Handle task timeout\n   * @param {Object} task - Task object\n   * @private\n   */\n  async handleTaskTimeout(task) {\n    const error = new Error(`Task ${task.id} timed out after ${task.timeout}ms`);\n    await this.handleTaskError(task, error, task.timeout);\n  },\n\n  /**\n   * Handle successful task completion\n   * @param {Object} task - Task object\n   * @param {any} result - Task result\n   * @param {number} executionTime - Task execution time\n   * @private\n   */\n  async handleTaskSuccess(task, result, executionTime) {\n    this.state.statistics.processed++;\n    this.state.statistics.succeeded++;\n\n    const totalProcessed = this.state.statistics.processed;\n    this.state.statistics.avgProcessingTime =\n      ((this.state.statistics.avgProcessingTime * (totalProcessed - 1)) + executionTime) / totalProcessed;\n\n    if (this.config.persistence.enabled && this.storageManager) {\n      await this.removePersistedTask(task);\n    }\n\n    EventManager.emit('queue:task:completed', {\n      queueName: task.queueName,\n      taskId: task.id,\n      executionTime,\n      result\n    });\n  },\n\n  /**\n   * Handle task error\n   * @param {Object} task - Task object\n   * @param {Error} error - Error object\n   * @param {number} executionTime - Task execution time\n   * @private\n   */\n  async handleTaskError(task, error, executionTime) {\n    this.state.statistics.processed++;\n\n    if (task.attempts <= task.maxRetries) {\n      let delay = task.retryDelay;\n\n      if (task.backoffStrategy === 'exponential') {\n        delay = task.retryDelay * Math.pow(2, task.attempts - 1);\n      } else if (task.backoffStrategy === 'linear') {\n        delay = task.retryDelay * task.attempts;\n      }\n\n      task.scheduledTime = Date.now() + delay;\n      const queue = this.state.queues.get(task.queueName);\n      queue.tasks.push(task);\n\n      if (queue.options.priority) {\n        this.sortQueueByPriority(queue);\n      }\n\n      this.state.statistics.retried++;\n\n      EventManager.emit('queue:task:retrying', {\n        queueName: task.queueName,\n        taskId: task.id,\n        attempt: task.attempts,\n        nextAttempt: new Date(task.scheduledTime),\n        error: {\n          message: error.message,\n          stack: error.stack\n        }\n      });\n    } else {\n      this.state.statistics.failed++;\n\n      if (this.config.persistence.enabled && this.storageManager) {\n        await this.removePersistedTask(task);\n      }\n\n      EventManager.emit('queue:task:failed', {\n        queueName: task.queueName,\n        taskId: task.id,\n        attempts: task.attempts,\n        executionTime,\n        error: {\n          message: error.message,\n          stack: error.stack\n        }\n      });\n\n      if (window.ErrorManager) {\n        ErrorManager.handle(error, {\n          context: `QueueManager.processTask(${task.queueName})`,\n          type: 'queue:task:error',\n          data: {\n            taskId: task.id,\n            queueName: task.queueName,\n            attempts: task.attempts\n          }\n        });\n      } else if (this.config.debug) {\n        console.error(`Task ${task.id} in queue ${task.queueName} failed after ${task.attempts} attempts:`, error);\n      }\n    }\n  },\n\n  /**\n   * Pause a queue\n   * @param {string} queueName - Queue name\n   * @returns {boolean} - Success status\n   */\n  pauseQueue(queueName) {\n    if (!this.state.queues.has(queueName)) {\n      return false;\n    }\n\n    const queue = this.state.queues.get(queueName);\n    queue.options.paused = true;\n    this.state.pausedQueues.add(queueName);\n\n    EventManager.emit('queue:paused', {queueName});\n\n    return true;\n  },\n\n  /**\n   * Resume a paused queue\n   * @param {string} queueName - Queue name\n   * @returns {boolean} - Success status\n   */\n  resumeQueue(queueName) {\n    if (!this.state.queues.has(queueName)) {\n      return false;\n    }\n\n    const queue = this.state.queues.get(queueName);\n    queue.options.paused = false;\n    this.state.pausedQueues.delete(queueName);\n\n    if (this.config.enabled && this.state.enabled) {\n      this.processNextTasks(queueName);\n    }\n\n    EventManager.emit('queue:resumed', {queueName});\n\n    return true;\n  },\n\n  /**\n   * Check if a queue is paused\n   * @param {string} queueName - Queue name\n   * @returns {boolean} - Whether queue is paused\n   */\n  isQueuePaused(queueName) {\n    if (!this.state.queues.has(queueName)) {\n      return false;\n    }\n\n    return this.state.queues.get(queueName).options.paused;\n  },\n\n  /**\n   * Clear all tasks from a queue\n   * @param {string} queueName - Queue name\n   * @returns {number} - Number of tasks cleared\n   */\n  clearQueue(queueName) {\n    if (!this.state.queues.has(queueName)) {\n      return 0;\n    }\n\n    const queue = this.state.queues.get(queueName);\n    const taskCount = queue.tasks.length;\n    queue.tasks = [];\n\n    if (this.config.persistence.enabled && this.storageManager) {\n      this.storageManager.deleteByQuery(\n        this.config.persistence.storeName,\n        {\n          index: 'queueName',\n          value: queueName\n        }\n      ).catch(error => {\n        console.error(`Failed to clear persisted tasks for queue ${queueName}:`, error);\n      });\n    }\n\n    EventManager.emit('queue:cleared', {queueName, taskCount});\n\n    return taskCount;\n  },\n\n  /**\n   * Get queue statistics\n   * @param {string} queueName - Queue name\n   * @returns {Object} - Queue statistics\n   */\n  getQueueStats(queueName) {\n    if (!this.state.queues.has(queueName)) {\n      return null;\n    }\n\n    const queue = this.state.queues.get(queueName);\n    const now = Date.now();\n\n    return {\n      name: queueName,\n      length: queue.tasks.length,\n      activeTasks: queue.activeTasks,\n      paused: queue.options.paused,\n      enabled: this.config.enabled && this.state.enabled,\n      ready: queue.tasks.filter(task => task.scheduledTime <= now).length,\n      scheduled: queue.tasks.filter(task => task.scheduledTime > now).length,\n      concurrency: queue.options.concurrency,\n      priority: queue.options.priority,\n      oldestTask: queue.tasks.length > 0 ?\n        new Date(Math.min(...queue.tasks.map(t => t.createdAt))) : null\n    };\n  },\n\n  /**\n   * Get queue length\n   * @param {string} queueName - Queue name\n   * @returns {number} - Queue length\n   */\n  getQueueLength(queueName) {\n    if (!this.state.queues.has(queueName)) {\n      return 0;\n    }\n\n    return this.state.queues.get(queueName).tasks.length;\n  },\n\n  /**\n   * Set queue priority mode\n   * @param {string} queueName - Queue name\n   * @param {boolean} priority - Whether queue uses priority\n   * @returns {boolean} - Success status\n   */\n  setQueuePriority(queueName, priority) {\n    if (!this.state.queues.has(queueName)) {\n      return false;\n    }\n\n    const queue = this.state.queues.get(queueName);\n    queue.options.priority = !!priority;\n\n    if (queue.options.priority) {\n      this.sortQueueByPriority(queue);\n    }\n\n    return true;\n  },\n\n  /**\n   * Set queue concurrency\n   * @param {string} queueName - Queue name\n   * @param {number} concurrency - Concurrency level\n   * @returns {boolean} - Success status\n   */\n  setQueueConcurrency(queueName, concurrency) {\n    if (!this.state.queues.has(queueName)) {\n      return false;\n    }\n\n    if (typeof concurrency !== 'number' || concurrency < 1) {\n      throw new Error('Concurrency must be a positive number');\n    }\n\n    const queue = this.state.queues.get(queueName);\n    queue.options.concurrency = concurrency;\n\n    if (this.config.enabled && this.state.enabled) {\n      this.processNextTasks(queueName);\n    }\n\n    return true;\n  },\n\n  /**\n   * Persist a task to storage\n   * @param {Object} task - Task object\n   * @returns {Promise<void>}\n   * @private\n   */\n  async persistTask(task) {\n    if (!this.config.persistence.enabled || !this.storageManager) {\n      return;\n    }\n\n    try {\n      if (task.callback) {\n        return;\n      }\n\n      const taskToStore = {\n        id: task.id,\n        queueName: task.queueName,\n        data: task.data,\n        priority: task.priority,\n        scheduledTime: task.scheduledTime,\n        attempts: task.attempts,\n        maxRetries: task.maxRetries,\n        retryDelay: task.retryDelay,\n        backoffStrategy: task.backoffStrategy,\n        timeout: task.timeout,\n        createdAt: task.createdAt\n      };\n\n      await this.storageManager.add(\n        this.config.persistence.storeName,\n        taskToStore\n      );\n    } catch (error) {\n      console.error('Failed to persist task:', error);\n    }\n  },\n\n  /**\n   * Remove a persisted task from storage\n   * @param {Object} task - Task object\n   * @returns {Promise<void>}\n   * @private\n   */\n  async removePersistedTask(task) {\n    if (!this.config.persistence.enabled || !this.storageManager) {\n      return;\n    }\n\n    try {\n      await this.storageManager.delete(\n        this.config.persistence.storeName,\n        task.id\n      );\n    } catch (error) {\n      if (this.config.debug) {\n        console.warn('Failed to remove persisted task:', error);\n      }\n    }\n  },\n\n  /**\n   * Start persistence sync\n   * @private\n   */\n  startPersistenceSync() {\n    if (!this.config.persistence.enabled || !this.storageManager) {\n      return;\n    }\n\n    if (this.state.persistenceTimer) {\n      clearInterval(this.state.persistenceTimer);\n    }\n\n    this.state.persistenceTimer = setInterval(() => {\n      this.syncPersistedTasks();\n    }, this.config.persistence.syncInterval);\n  },\n\n  /**\n   * Synchronize tasks with persistence storage\n   * @returns {Promise<void>}\n   * @private\n   */\n  async syncPersistedTasks() {\n    if (!this.config.persistence.enabled || !this.storageManager) {\n      return;\n    }\n\n    try {\n      for (const [queueName, queue] of this.state.queues.entries()) {\n        const tasksToPersist = queue.tasks.filter(task =>\n          !task.callback && !task._persisted\n        );\n\n        for (const task of tasksToPersist) {\n          await this.persistTask(task);\n          task._persisted = true;\n        }\n      }\n\n      const count = await this.storageManager.count(\n        this.config.persistence.storeName\n      );\n\n      if (count > this.config.persistence.maxPersistedTasks) {\n        const toRemove = count - this.config.persistence.maxPersistedTasks;\n        const oldestTasks = await this.storageManager.getAll(\n          this.config.persistence.storeName,\n          {\n            index: 'createdAt',\n            direction: 'asc',\n            limit: toRemove\n          }\n        );\n\n        for (const task of oldestTasks) {\n          await this.storageManager.delete(\n            this.config.persistence.storeName,\n            task.id\n          );\n        }\n      }\n    } catch (error) {\n      console.error('Failed to sync persisted tasks:', error);\n    }\n  },\n\n  /**\n   * Load tasks from persistence storage\n   * @returns {Promise<number>} - Number of tasks loaded\n   * @private\n   */\n  async loadPersistedTasks() {\n    if (!this.config.persistence.enabled || !this.storageManager) {\n      return 0;\n    }\n\n    try {\n      const tasks = await this.storageManager.getAll(\n        this.config.persistence.storeName\n      );\n\n      if (tasks.length === 0) {\n        return 0;\n      }\n\n      let loadedCount = 0;\n\n      for (const task of tasks) {\n        if (!this.state.queues.has(task.queueName)) {\n          this.createQueue(task.queueName);\n        }\n\n        const queue = this.state.queues.get(task.queueName);\n        queue.tasks.push({\n          ...task,\n          _persisted: true\n        });\n        loadedCount++;\n      }\n\n      for (const queue of this.state.queues.values()) {\n        if (queue.options.priority) {\n          this.sortQueueByPriority(queue);\n        }\n      }\n\n      if (this.config.enabled && this.state.enabled) {\n        for (const queueName of this.state.queues.keys()) {\n          this.processNextTasks(queueName);\n        }\n      }\n\n      EventManager.emit('queue:tasks:loaded', {count: loadedCount});\n\n      return loadedCount;\n    } catch (error) {\n      console.error('Failed to load persisted tasks:', error);\n      return 0;\n    }\n  },\n\n  /**\n   * Initialize worker pool\n   * @private\n   */\n  initWorkerPool() {\n    const size = this.config.workerPool.size;\n    this.state.workers = [];\n\n    for (let i = 0; i < size; i++) {\n      this.state.workers.push({\n        id: `worker_${i}`,\n        busy: false,\n        task: null,\n        lastActive: Date.now()\n      });\n    }\n  },\n\n  /**\n   * Submit task to worker pool\n   * @param {Object} task - Task object\n   * @private\n   */\n  submitTaskToWorkerPool(task) {\n    const idleWorker = this.state.workers.find(worker => !worker.busy);\n\n    if (idleWorker) {\n      idleWorker.busy = true;\n      idleWorker.task = task;\n      idleWorker.lastActive = Date.now();\n\n      this.processTaskInWorker(idleWorker);\n    } else {\n      const queue = this.state.queues.get(task.queueName);\n      queue.tasks.unshift(task);\n      queue.activeTasks--;\n    }\n  },\n\n  /**\n   * Process task in worker\n   * @param {Object} worker - Worker object\n   * @private\n   */\n  async processTaskInWorker(worker) {\n    const task = worker.task;\n\n    try {\n      await this.processTask(task);\n    } finally {\n      worker.busy = false;\n      worker.task = null;\n      worker.lastActive = Date.now();\n\n      for (const queueName of this.state.queues.keys()) {\n        this.processNextTasks(queueName);\n      }\n    }\n  },\n\n  /**\n   * Get global queue statistics\n   * @returns {Object} - Global queue statistics\n   */\n  getGlobalStats() {\n    const queues = {};\n    let totalTasks = 0;\n    let activeTasks = 0;\n    let pausedQueues = 0;\n\n    for (const [name, queue] of this.state.queues.entries()) {\n      totalTasks += queue.tasks.length;\n      activeTasks += queue.activeTasks;\n\n      if (queue.options.paused) {\n        pausedQueues++;\n      }\n\n      queues[name] = {\n        length: queue.tasks.length,\n        active: queue.activeTasks,\n        paused: queue.options.paused,\n        concurrency: queue.options.concurrency\n      };\n    }\n\n    return {\n      enabled: this.config.enabled && this.state.enabled,\n      queues,\n      queueCount: this.state.queues.size,\n      pausedQueues,\n      totalTasks,\n      activeTasks,\n      processed: this.state.statistics.processed,\n      succeeded: this.state.statistics.succeeded,\n      failed: this.state.statistics.failed,\n      retried: this.state.statistics.retried,\n      averageProcessingTime: this.state.statistics.avgProcessingTime,\n      workers: {\n        total: this.state.workers.length,\n        active: this.state.workers.filter(w => w.busy).length\n      }\n    };\n  },\n\n  /**\n   * Pause all queues\n   * @returns {number} - Number of queues paused\n   */\n  pauseAll() {\n    let count = 0;\n\n    for (const queueName of this.state.queues.keys()) {\n      if (!this.isQueuePaused(queueName)) {\n        this.pauseQueue(queueName);\n        count++;\n      }\n    }\n\n    EventManager.emit('queue:all:paused', {count});\n\n    return count;\n  },\n\n  /**\n   * Resume all queues\n   * @returns {number} - Number of queues resumed\n   */\n  resumeAll() {\n    let count = 0;\n\n    for (const queueName of this.state.pausedQueues) {\n      this.resumeQueue(queueName);\n      count++;\n    }\n\n    EventManager.emit('queue:all:resumed', {count});\n\n    return count;\n  },\n\n  /**\n   * Clear all queues\n   * @returns {number} - Number of tasks cleared\n   */\n  clearAll() {\n    let count = 0;\n\n    for (const queueName of this.state.queues.keys()) {\n      count += this.clearQueue(queueName);\n    }\n\n    EventManager.emit('queue:all:cleared', {count});\n\n    return count;\n  },\n\n  /**\n   * Clean up resources\n   */\n  destroy() {\n    if (this.state.persistenceTimer) {\n      clearInterval(this.state.persistenceTimer);\n      this.state.persistenceTimer = null;\n    }\n\n    this.clearAll();\n\n    this.state = {\n      initialized: false,\n      enabled: false,\n      queues: new Map(),\n      workers: [],\n      activeWorkers: 0,\n      runningTasks: new Map(),\n      taskCounter: 0,\n      persistenceTimer: null,\n      rateLimitCounter: 0,\n      rateLimitResetTime: 0,\n      pausedQueues: new Set(),\n      statistics: {\n        processed: 0,\n        succeeded: 0,\n        failed: 0,\n        retried: 0,\n        avgProcessingTime: 0\n      }\n    };\n\n    EventManager.emit('queue:destroyed');\n  }\n};\n\nif (window.Now?.registerManager) {\n  Now.registerManager('queue', QueueManager);\n}\n\n// Expose globally\nwindow.QueueManager = QueueManager;\n"],"names":["QueueManager","config","debug","enabled","defaultConcurrency","defaultMaxRetries","defaultRetryDelay","defaultBackoffStrategy","defaultTimeout","persistence","storeName","syncInterval","maxPersistedTasks","rateLimiting","limit","interval","fairness","workerPool","size","navigator","hardwareConcurrency","idleTimeout","state","initialized","queues","Map","workers","activeWorkers","runningTasks","taskCounter","persistenceTimer","rateLimitCounter","rateLimitResetTime","pausedQueues","Set","statistics","processed","succeeded","failed","retried","avgProcessingTime","init","options","this","storageManager","_a","window","Now","getManager","storageError","console","error","warn","createDatabase","name","defaultDB","version","defaultVersion","stores","keyPath","autoIncrement","indexes","loadPersistedTasks","dbError","initWorkerPool","EventManager","emit","manager","ErrorManager","handle","context","type","enable","startPersistenceSync","queueName","keys","processNextTasks","disable","clearInterval","forEach","worker","busy","task","createQueue","has","getQueue","queue","tasks","concurrency","maxRetries","retryDelay","backoffStrategy","timeout","priority","fifo","paused","activeTasks","isProcessing","set","getQueueInterface","Error","add","addTask","addBulk","addBulkTasks","pause","pauseQueue","resume","resumeQueue","clear","clearQueue","getStats","getQueueStats","getLength","getQueueLength","setPriority","setQueuePriority","setConcurrency","setQueueConcurrency","getName","isPaused","isQueuePaused","isEnabled","get","taskId","Date","now","isFunction","taskObject","id","callback","data","scheduledTime","delay","attempts","createdAt","push","sortQueueByPriority","persistTask","scheduled","Array","isArray","map","sort","a","b","availableTasks","filter","length","setTimeout","tasksToProcess","Math","min","i","taskIndex","findIndex","splice","submitTaskToWorkerPool","processTask","timeoutId","handleTaskTimeout","startTime","performance","result","attempt","Promise","resolve","url","executeApiTask","executeEventTask","clearTimeout","handleTaskSuccess","handleTaskError","delete","method","headers","methodLower","toLowerCase","apiService","ApiService","_b","call","http","simpleFetch","event","executionTime","totalProcessed","removePersistedTask","pow","nextAttempt","message","stack","taskCount","deleteByQuery","index","value","catch","ready","oldestTask","t","taskToStore","setInterval","syncPersistedTasks","entries","tasksToPersist","_persisted","count","toRemove","oldestTasks","getAll","direction","loadedCount","values","lastActive","idleWorker","find","processTaskInWorker","unshift","getGlobalStats","totalTasks","active","queueCount","averageProcessingTime","total","w","pauseAll","resumeAll","clearAll","destroy","registerManager"],"mappings":"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"}